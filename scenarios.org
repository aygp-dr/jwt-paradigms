#+TITLE: JWT Token Scenarios
#+AUTHOR: Aidan Pace
#+EMAIL: apace@defrecord.com
#+DATE: [2025-04-28]
#+DESCRIPTION: Advanced JWT token usage patterns across languages
#+LANGUAGE: en
#+OPTIONS: toc:3 num:t ^:nil
#+STARTUP: showeverything
#+PROPERTY: header-args :exports both :eval never-export

* JWT Advanced Use Cases
:PROPERTIES:
:CUSTOM_ID: advanced-jwt-use-cases
:END:

** Subscription Tokens
:PROPERTIES:
:CUSTOM_ID: subscription-tokens
:END:

Subscription tokens encode user subscription status, plan details, and expiration information. They allow services to verify access rights without database lookups.

*** Node.js Implementation
#+BEGIN_SRC javascript :tangle examples/subscription/node.js :mkdirp yes
const jwt = require('jsonwebtoken');
const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key';

// Generate a subscription token
function generateSubscriptionToken(userId, planDetails) {
  const now = Math.floor(Date.now() / 1000);
  const payload = {
    sub: userId,
    iat: now,
    exp: now + (planDetails.durationDays * 86400), // Convert days to seconds
    plan: {
      name: planDetails.name,
      tier: planDetails.tier,
      features: planDetails.features,
      isActive: true
    },
    meta: {
      lastBillingDate: planDetails.lastBillingDate,
      nextBillingDate: planDetails.nextBillingDate
    }
  };
  
  return jwt.sign(payload, SECRET_KEY, { algorithm: 'HS256' });
}

// Verify a subscription token
function verifySubscriptionAccess(token) {
  try {
    const decoded = jwt.verify(token, SECRET_KEY);
    
    // Check if token contains subscription plan
    if (!decoded.plan || !decoded.plan.isActive) {
      return { valid: false, reason: 'No active subscription found' };
    }
    
    // Check for required features
    return {
      valid: true,
      userId: decoded.sub,
      plan: decoded.plan.name,
      tier: decoded.plan.tier,
      features: decoded.plan.features,
      expiresAt: new Date(decoded.exp * 1000)
    };
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return { valid: false, reason: 'Subscription expired' };
    }
    return { valid: false, reason: 'Invalid token' };
  }
}

// Example usage
const planDetails = {
  name: 'Premium',
  tier: 2,
  features: ['content-access', 'hd-streaming', 'offline-download'],
  durationDays: 30,
  lastBillingDate: '2025-04-01',
  nextBillingDate: '2025-05-01'
};

const token = generateSubscriptionToken('user123', planDetails);
console.log('Subscription Token:', token);

const verification = verifySubscriptionAccess(token);
console.log('Verification Result:', verification);
#+END_SRC

*** Python Implementation
#+BEGIN_SRC python :tangle examples/subscription/python_sub.py :mkdirp yes
import jwt
import time
import os
from datetime import datetime, timedelta

SECRET_KEY = os.environ.get('JWT_SECRET', 'your-secret-key')

def generate_subscription_token(user_id, plan_details):
    """Generate a JWT token containing subscription information"""
    now = int(time.time())
    expiration = now + (plan_details['duration_days'] * 86400)  # Convert days to seconds
    
    payload = {
        'sub': user_id,
        'iat': now,
        'exp': expiration,
        'plan': {
            'name': plan_details['name'],
            'tier': plan_details['tier'],
            'features': plan_details['features'],
            'is_active': True
        },
        'meta': {
            'last_billing_date': plan_details['last_billing_date'],
            'next_billing_date': plan_details['next_billing_date']
        }
    }
    
    return jwt.encode(payload, SECRET_KEY, algorithm='HS256')

def verify_subscription_access(token):
    """Verify a subscription token and check if the user has access"""
    try:
        decoded = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
        
        # Check if token contains subscription plan
        if not decoded.get('plan') or not decoded['plan'].get('is_active'):
            return {'valid': False, 'reason': 'No active subscription found'}
        
        # Return subscription details
        return {
            'valid': True,
            'user_id': decoded['sub'],
            'plan': decoded['plan']['name'],
            'tier': decoded['plan']['tier'],
            'features': decoded['plan']['features'],
            'expires_at': datetime.fromtimestamp(decoded['exp']).isoformat()
        }
    except jwt.ExpiredSignatureError:
        return {'valid': False, 'reason': 'Subscription expired'}
    except (jwt.InvalidTokenError, KeyError):
        return {'valid': False, 'reason': 'Invalid token'}

# Example usage
if __name__ == "__main__":
    plan_details = {
        'name': 'Premium',
        'tier': 2,
        'features': ['content-access', 'hd-streaming', 'offline-download'],
        'duration_days': 30,
        'last_billing_date': '2025-04-01',
        'next_billing_date': '2025-05-01'
    }
    
    token = generate_subscription_token('user123', plan_details)
    print(f"Subscription Token: {token}")
    
    verification = verify_subscription_access(token)
    print(f"Verification Result: {verification}")
#+END_SRC

** Proxy Authentication Tokens
:PROPERTIES:
:CUSTOM_ID: proxy-tokens
:END:

Proxy tokens allow a service to make authenticated requests to another service on behalf of a user without exposing the original user's credentials.

*** TypeScript Implementation
#+BEGIN_SRC typescript :tangle examples/proxy/typescript_proxy.ts :mkdirp yes
import * as jwt from 'jsonwebtoken';
import * as crypto from 'crypto';
import { Request, Response, NextFunction } from 'express';

// Configuration
const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key';
const SERVICE_ID = 'analytics-service';
const TTL_SECONDS = 300; // 5 minutes

interface ProxyTokenPayload {
  sub: string;        // Original user ID
  iss: string;        // Issuing service
  aud: string;        // Target service
  orig: string;       // Original token fingerprint
  iat: number;        // Issued at time
  exp: number;        // Expiration time
  scope: string[];    // Allowed actions
  ctx: {              // Context data
    req_id: string;
    source_ip: string;
    [key: string]: any;
  };
}

/**
 * Generate a proxy token for making downstream service calls
 */
function generateProxyToken(
  userId: string,
  originalToken: string,
  targetService: string,
  scopes: string[],
  requestContext: Record<string, any>
): string {
  // Create fingerprint of original token to prevent token substitution attacks
  const tokenFingerprint = crypto
    .createHash('sha256')
    .update(originalToken)
    .digest('hex');
  
  const now = Math.floor(Date.now() / 1000);
  
  const payload: ProxyTokenPayload = {
    sub: userId,
    iss: SERVICE_ID,
    aud: targetService,
    orig: tokenFingerprint,
    iat: now,
    exp: now + TTL_SECONDS,
    scope: scopes,
    ctx: {
      req_id: requestContext.requestId || crypto.randomUUID(),
      source_ip: requestContext.ip || '0.0.0.0',
      ...requestContext
    }
  };
  
  return jwt.sign(payload, SECRET_KEY, { algorithm: 'HS256' });
}

/**
 * Verify a proxy token in a downstream service
 */
function verifyProxyToken(token: string, expectedAudience: string): ProxyTokenPayload | null {
  try {
    const decoded = jwt.verify(token, SECRET_KEY, {
      algorithms: ['HS256'],
      audience: expectedAudience
    }) as ProxyTokenPayload;
    
    return decoded;
  } catch (error) {
    console.error('Proxy token verification failed:', error);
    return null;
  }
}

/**
 * Express middleware for proxy authentication
 */
function proxyAuthMiddleware(req: Request, res: Response, next: NextFunction): void {
  const proxyToken = req.headers.authorization?.replace('Bearer ', '');
  
  if (!proxyToken) {
    res.status(401).json({ error: 'Proxy authentication required' });
    return;
  }
  
  const serviceId = req.headers['x-service-id'] as string;
  
  if (!serviceId) {
    res.status(400).json({ error: 'Service ID header required' });
    return;
  }
  
  const decoded = verifyProxyToken(proxyToken, SERVICE_ID);
  
  if (!decoded) {
    res.status(403).json({ error: 'Invalid proxy token' });
    return;
  }
  
  // Check if the calling service is the expected issuer
  if (decoded.iss !== serviceId) {
    res.status(403).json({ error: 'Token issuer mismatch' });
    return;
  }
  
  // Add the proxy context to the request for later use
  req['proxyContext'] = {
    userId: decoded.sub,
    scopes: decoded.scope,
    context: decoded.ctx
  };
  
  next();
}

// Example usage
const originalUserToken = 'eyJhbGciOiJIUzI1NiIsInR...';
const userId = 'user456';
const targetService = 'payment-service';
const allowedScopes = ['read:transactions', 'process:refund'];
const requestContext = {
  requestId: 'req_12345',
  ip: '192.168.1.100',
  userAgent: 'Mozilla/5.0...',
  route: '/api/transactions'
};

const proxyToken = generateProxyToken(
  userId,
  originalUserToken,
  targetService,
  allowedScopes,
  requestContext
);

console.log('Proxy Token:', proxyToken);

// Simulate verification in the target service
const verificationResult = verifyProxyToken(proxyToken, targetService);
console.log('Verification Result:', verificationResult);
#+END_SRC

*** Rust Implementation
#+BEGIN_SRC rust :tangle examples/proxy/rust_proxy.rs :mkdirp yes
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::collections::HashMap;
use std::env;
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// Configuration constants
const SERVICE_ID: &str = "analytics-service";
const TTL_SECONDS: u64 = 300; // 5 minutes

#[derive(Debug, Serialize, Deserialize)]
struct Context {
    req_id: String,
    source_ip: String,
    #[serde(flatten)]
    additional: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize)]
struct ProxyTokenClaims {
    sub: String,      // Original user ID
    iss: String,      // Issuing service
    aud: String,      // Target service
    orig: String,     // Original token fingerprint
    iat: u64,         // Issued at time
    exp: u64,         // Expiration time
    scope: Vec<String>, // Allowed actions
    ctx: Context,     // Context data
}

/// Generate a proxy token for making downstream service calls
fn generate_proxy_token(
    user_id: &str,
    original_token: &str,
    target_service: &str,
    scopes: Vec<String>,
    request_context: HashMap<String, serde_json::Value>,
) -> Result<String, jsonwebtoken::errors::Error> {
    // Create fingerprint of original token to prevent token substitution attacks
    let mut hasher = Sha256::new();
    hasher.update(original_token.as_bytes());
    let token_fingerprint = format!("{:x}", hasher.finalize());
    
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();
    
    // Extract specific fields or set defaults
    let req_id = match request_context.get("requestId") {
        Some(serde_json::Value::String(id)) => id.clone(),
        _ => Uuid::new_v4().to_string(),
    };
    
    let source_ip = match request_context.get("ip") {
        Some(serde_json::Value::String(ip)) => ip.clone(),
        _ => "0.0.0.0".to_string(),
    };
    
    // Create a new HashMap for additional context, excluding fields we've already used
    let mut additional_ctx = request_context.clone();
    additional_ctx.remove("requestId");
    additional_ctx.remove("ip");
    
    let claims = ProxyTokenClaims {
        sub: user_id.to_string(),
        iss: SERVICE_ID.to_string(),
        aud: target_service.to_string(),
        orig: token_fingerprint,
        iat: now,
        exp: now + TTL_SECONDS,
        scope: scopes,
        ctx: Context {
            req_id,
            source_ip,
            additional: additional_ctx,
        },
    };
    
    let secret_key = env::var("JWT_SECRET").unwrap_or_else(|_| "your-secret-key".to_string());
    encode(
        &Header::new(Algorithm::HS256),
        &claims,
        &EncodingKey::from_secret(secret_key.as_bytes()),
    )
}

/// Verify a proxy token in a downstream service
fn verify_proxy_token(
    token: &str,
    expected_audience: &str,
) -> Result<ProxyTokenClaims, jsonwebtoken::errors::Error> {
    let secret_key = env::var("JWT_SECRET").unwrap_or_else(|_| "your-secret-key".to_string());
    
    let mut validation = Validation::new(Algorithm::HS256);
    validation.set_audience(&[expected_audience]);
    
    let token_data = decode::<ProxyTokenClaims>(
        token,
        &DecodingKey::from_secret(secret_key.as_bytes()),
        &validation,
    )?;
    
    Ok(token_data.claims)
}

fn main() {
    // Example usage
    let original_user_token = "eyJhbGciOiJIUzI1NiIsInR...";
    let user_id = "user456";
    let target_service = "payment-service";
    let allowed_scopes = vec![
        "read:transactions".to_string(),
        "process:refund".to_string(),
    ];
    
    // Create a request context
    let mut request_context = HashMap::new();
    request_context.insert("requestId".to_string(), serde_json::Value::String("req_12345".to_string()));
    request_context.insert("ip".to_string(), serde_json::Value::String("192.168.1.100".to_string()));
    request_context.insert("userAgent".to_string(), serde_json::Value::String("Mozilla/5.0...".to_string()));
    request_context.insert("route".to_string(), serde_json::Value::String("/api/transactions".to_string()));
    
    match generate_proxy_token(
        user_id,
        original_user_token,
        target_service,
        allowed_scopes,
        request_context,
    ) {
        Ok(proxy_token) => {
            println!("Proxy Token: {}", proxy_token);
            
            // Simulate verification in the target service
            match verify_proxy_token(&proxy_token, target_service) {
                Ok(verification_result) => {
                    println!("Verification successful: {:?}", verification_result);
                }
                Err(e) => {
                    println!("Verification failed: {}", e);
                }
            }
        }
        Err(e) => {
            println!("Token generation failed: {}", e);
        }
    }
}
#+END_SRC

** Refresh Tokens
:PROPERTIES:
:CUSTOM_ID: refresh-tokens
:END:

Refresh tokens enable obtaining new access tokens without re-authentication. They typically have a longer lifetime and are stored securely.

*** Python Implementation
#+BEGIN_SRC python :tangle examples/refresh/python_refresh.py :mkdirp yes
import jwt
import secrets
import time
import uuid
import redis
import os
from datetime import datetime, timedelta

# Configuration
SECRET_KEY = os.environ.get('JWT_SECRET', 'your-secret-key')
REFRESH_SECRET = os.environ.get('REFRESH_SECRET', 'your-refresh-secret')

# Redis connection for token storage and revocation
redis_client = redis.Redis(
    host=os.environ.get('REDIS_HOST', 'localhost'),
    port=int(os.environ.get('REDIS_PORT', 6379)),
    db=int(os.environ.get('REDIS_DB', 0)),
    decode_responses=True
)

class TokenService:
    """Service for managing access and refresh tokens"""
    
    def __init__(self):
        self.access_ttl = 900  # 15 minutes
        self.refresh_ttl = 2592000  # 30 days
    
    def generate_token_pair(self, user_id, roles, permissions):
        """Generate a new access+refresh token pair"""
        now = int(time.time())
        
        # Create a unique refresh token ID
        refresh_jti = str(uuid.uuid4())
        
        # Access token payload
        access_payload = {
            'sub': user_id,
            'iat': now,
            'exp': now + self.access_ttl,
            'jti': str(uuid.uuid4()),
            'roles': roles,
            'permissions': permissions
        }
        
        # Refresh token payload
        refresh_payload = {
            'sub': user_id,
            'iat': now,
            'exp': now + self.refresh_ttl,
            'jti': refresh_jti,
            'type': 'refresh'
        }
        
        # Create tokens
        access_token = jwt.encode(access_payload, SECRET_KEY, algorithm='HS256')
        refresh_token = jwt.encode(refresh_payload, REFRESH_SECRET, algorithm='HS256')
        
        # Store refresh token in Redis for validation/revocation
        self._store_refresh_token(refresh_jti, user_id, now + self.refresh_ttl)
        
        return {
            'access_token': access_token,
            'token_type': 'Bearer',
            'expires_in': self.access_ttl,
            'refresh_token': refresh_token,
            'refresh_expires_in': self.refresh_ttl
        }
    
    def refresh_access_token(self, refresh_token):
        """Use a refresh token to generate a new access token"""
        try:
            # Verify the refresh token
            decoded = jwt.decode(refresh_token, REFRESH_SECRET, algorithms=['HS256'])
            
            # Check if it's a refresh token
            if decoded.get('type') != 'refresh':
                return {'error': 'Invalid token type'}
            
            # Check if token has been revoked
            if not self._validate_refresh_token(decoded['jti']):
                return {'error': 'Token has been revoked'}
            
            # Get user data (in a real app, you'd get the latest roles/permissions)
            user_id = decoded['sub']
            user_data = self._get_user_data(user_id)
            
            # Generate a new access token
            now = int(time.time())
            new_access_payload = {
                'sub': user_id,
                'iat': now,
                'exp': now + self.access_ttl,
                'jti': str(uuid.uuid4()),
                'roles': user_data['roles'],
                'permissions': user_data['permissions']
            }
            
            new_access_token = jwt.encode(new_access_payload, SECRET_KEY, algorithm='HS256')
            
            return {
                'access_token': new_access_token,
                'token_type': 'Bearer',
                'expires_in': self.access_ttl
            }
            
        except jwt.ExpiredSignatureError:
            return {'error': 'Refresh token expired'}
        except jwt.InvalidTokenError:
            return {'error': 'Invalid token'}
    
    def revoke_refresh_token(self, refresh_token):
        """Revoke a refresh token"""
        try:
            decoded = jwt.decode(refresh_token, REFRESH_SECRET, algorithms=['HS256'])
            self._revoke_refresh_token(decoded['jti'])
            return {'success': True, 'message': 'Token revoked'}
        except (jwt.InvalidTokenError, KeyError):
            return {'error': 'Invalid token'}
    
    def _store_refresh_token(self, jti, user_id, expiry):
        """Store refresh token metadata in Redis"""
        # Key format: refresh_token:{jti}
        key = f"refresh_token:{jti}"
        redis_client.hset(key, mapping={
            'user_id': user_id,
            'created_at': int(time.time()),
            'revoked': 'false'
        })
        # Set expiration
        redis_client.expireat(key, expiry)
    
    def _validate_refresh_token(self, jti):
        """Check if a refresh token is valid and not revoked"""
        key = f"refresh_token:{jti}"
        # Check if token exists and is not revoked
        token_data = redis_client.hgetall(key)
        return token_data and token_data.get('revoked') == 'false'
    
    def _revoke_refresh_token(self, jti):
        """Mark a refresh token as revoked"""
        key = f"refresh_token:{jti}"
        redis_client.hset(key, 'revoked', 'true')
    
    def _get_user_data(self, user_id):
        """Get latest user data (roles/permissions)"""
        # In a real app, you would fetch this from your database
        # This is a mockup for demonstration
        return {
            'roles': ['user', 'subscriber'],
            'permissions': ['read:content', 'post:comments']
        }

# Example usage
if __name__ == "__main__":
    token_service = TokenService()
    
    # Generate token pair for a user
    user_id = 'user789'
    roles = ['user', 'subscriber']
    permissions = ['read:content', 'post:comments']
    
    token_pair = token_service.generate_token_pair(user_id, roles, permissions)
    print(f"Token Pair: {token_pair}\n")
    
    # Simulate using the refresh token to get a new access token
    refresh_result = token_service.refresh_access_token(token_pair['refresh_token'])
    print(f"Refresh Result: {refresh_result}\n")
    
    # Revoke the refresh token
    revoke_result = token_service.revoke_refresh_token(token_pair['refresh_token'])
    print(f"Revoke Result: {revoke_result}\n")
    
    # Try to use the revoked refresh token
    failed_refresh = token_service.refresh_access_token(token_pair['refresh_token'])
    print(f"Using Revoked Token: {failed_refresh}")
#+END_SRC

*** TypeScript Implementation
#+BEGIN_SRC typescript :tangle examples/refresh/typescript_refresh.ts :mkdirp yes
import * as jwt from 'jsonwebtoken';
import * as crypto from 'crypto';
import { RedisClientType } from 'redis';

// Configuration
const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key';
const REFRESH_SECRET = process.env.REFRESH_SECRET || 'your-refresh-secret';

interface AccessTokenPayload {
  sub: string;        // User ID
  iat: number;        // Issued at time
  exp: number;        // Expiration time
  jti: string;        // JWT ID
  roles: string[];    // User roles
  permissions: string[]; // Specific permissions
}

interface RefreshTokenPayload {
  sub: string;        // User ID
  iat: number;        // Issued at time
  exp: number;        // Expiration time
  jti: string;        // JWT ID
  type: 'refresh';    // Token type
}

interface UserData {
  roles: string[];
  permissions: string[];
}

interface TokenPair {
  access_token: string;
  token_type: string;
  expires_in: number;
  refresh_token: string;
  refresh_expires_in: number;
}

interface TokenRefreshResult {
  access_token?: string;
  token_type?: string;
  expires_in?: number;
  error?: string;
}

interface TokenRevokeResult {
  success?: boolean;
  message?: string;
  error?: string;
}

class TokenService {
  private redisClient: RedisClientType;
  private accessTtl: number = 900;    // 15 minutes
  private refreshTtl: number = 2592000; // 30 days
  
  constructor(redisClient: RedisClientType) {
    this.redisClient = redisClient;
  }
  
  /**
   * Generate a new access+refresh token pair
   */
  public async generateTokenPair(
    userId: string,
    roles: string[],
    permissions: string[]
  ): Promise<TokenPair> {
    const now = Math.floor(Date.now() / 1000);
    
    // Create a unique refresh token ID
    const refreshJti = crypto.randomUUID();
    
    // Access token payload
    const accessPayload: AccessTokenPayload = {
      sub: userId,
      iat: now,
      exp: now + this.accessTtl,
      jti: crypto.randomUUID(),
      roles,
      permissions
    };
    
    // Refresh token payload
    const refreshPayload: RefreshTokenPayload = {
      sub: userId,
      iat: now,
      exp: now + this.refreshTtl,
      jti: refreshJti,
      type: 'refresh'
    };
    
    // Create tokens
    const accessToken = jwt.sign(accessPayload, SECRET_KEY, { algorithm: 'HS256' });
    const refreshToken = jwt.sign(refreshPayload, REFRESH_SECRET, { algorithm: 'HS256' });
    
    // Store refresh token in Redis for validation/revocation
    await this.storeRefreshToken(refreshJti, userId, now + this.refreshTtl);
    
    return {
      access_token: accessToken,
      token_type: 'Bearer',
      expires_in: this.accessTtl,
      refresh_token: refreshToken,
      refresh_expires_in: this.refreshTtl
    };
  }
  
  /**
   * Use a refresh token to generate a new access token
   */
  public async refreshAccessToken(refreshToken: string): Promise<TokenRefreshResult> {
    try {
      // Verify the refresh token
      const decoded = jwt.verify(refreshToken, REFRESH_SECRET) as RefreshTokenPayload;
      
      // Check if it's a refresh token
      if (decoded.type !== 'refresh') {
        return { error: 'Invalid token type' };
      }
      
      // Check if token has been revoked
      const isValid = await this.validateRefreshToken(decoded.jti);
      if (!isValid) {
        return { error: 'Token has been revoked' };
      }
      
      // Get user data (in a real app, you'd get the latest roles/permissions)
      const userId = decoded.sub;
      const userData = await this.getUserData(userId);
      
      // Generate a new access token
      const now = Math.floor(Date.now() / 1000);
      const newAccessPayload: AccessTokenPayload = {
        sub: userId,
        iat: now,
        exp: now + this.accessTtl,
        jti: crypto.randomUUID(),
        roles: userData.roles,
        permissions: userData.permissions
      };
      
      const newAccessToken = jwt.sign(newAccessPayload, SECRET_KEY, { algorithm: 'HS256' });
      
      return {
        access_token: newAccessToken,
        token_type: 'Bearer',
        expires_in: this.accessTtl
      };
      
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        return { error: 'Refresh token expired' };
      }
      return { error: 'Invalid token' };
    }
  }
  
  /**
   * Revoke a refresh token
   */
  public async revokeRefreshToken(refreshToken: string): Promise<TokenRevokeResult> {
    try {
      const decoded = jwt.verify(refreshToken, REFRESH_SECRET) as RefreshTokenPayload;
      await this.revokeRefreshTokenById(decoded.jti);
      return { success: true, message: 'Token revoked' };
    } catch (error) {
      return { error: 'Invalid token' };
    }
  }
  
  /**
   * Store refresh token metadata in Redis
   */
  private async storeRefreshToken(jti: string, userId: string, expiry: number): Promise<void> {
    // Key format: refresh_token:{jti}
    const key = `refresh_token:${jti}`;
    
    await this.redisClient.hSet(key, {
      user_id: userId,
      created_at: Math.floor(Date.now() / 1000).toString(),
      revoked: 'false'
    });
    
    // Set expiration
    await this.redisClient.expireAt(key, expiry);
  }
  
  /**
   * Check if a refresh token is valid and not revoked
   */
  private async validateRefreshToken(jti: string): Promise<boolean> {
    const key = `refresh_token:${jti}`;
    // Check if token exists and is not revoked
    const tokenData = await this.redisClient.hGetAll(key);
    return !!tokenData && tokenData.revoked === 'false';
  }
  
  /**
   * Mark a refresh token as revoked
   */
  private async revokeRefreshTokenById(jti: string): Promise<void> {
    const key = `refresh_token:${jti}`;
    await this.redisClient.hSet(key, 'revoked', 'true');
  }
  
  /**
   * Get latest user data (roles/permissions)
   */
  private async getUserData(userId: string): Promise<UserData> {
    // In a real app, you would fetch this from your database
    // This is a mockup for demonstration
    return {
      roles: ['user', 'subscriber'],
      permissions: ['read:content', 'post:comments']
    };
  }
}

// Example usage in an Express app:
/*
import express from 'express';
import { createClient } from 'redis';

const app = express();
app.use(express.json());

// Initialize Redis client
const redisClient = createClient({
  url: process.env.REDIS_URL || 'redis://localhost:6379'
});
redisClient.connect().catch(console.error);

// Initialize token service
const tokenService = new TokenService(redisClient);

// Login endpoint
app.post('/api/auth/login', async (req, res) => {
  // Validate credentials (not shown)
  const { username, password } = req.body;
  
  // Get user from database (not shown)
  const user = { id: 'user123', roles: ['user'], permissions: ['read:content'] };
  
  // Generate tokens
  const tokenPair = await tokenService.generateTokenPair(
    user.id,
    user.roles,
    user.permissions
  );
  
  res.json(tokenPair);
});

// Refresh token endpoint
app.post('/api/auth/refresh', async (req, res) => {
  const { refresh_token } = req.body;
  
  if (!refresh_token) {
    return res.status(400).json({ error: 'Refresh token is required' });
  }
  
  const result = await tokenService.refreshAccessToken(refresh_token);
  
  if (result.error) {
    return res.status(401).json({ error: result.error });
  }
  
  res.json(result);
});

// Logout endpoint
app.post('/api/auth/logout', async (req, res) => {
  const { refresh_token } = req.body;
  
  if (!refresh_token) {
    return res.status(400).json({ error: 'Refresh token is required' });
  }
  
  const result = await tokenService.revokeRefreshToken(refresh_token);
  
  if (result.error) {
    return res.status(401).json({ error: result.error });
  }
  
  res.json(result);
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
*/
#+END_SRC

** Token Revocation
:PROPERTIES:
:CUSTOM_ID: token-revocation
:END:

Token revocation enables invalidating tokens before their expiration, essential for security events like logouts or password changes.

*** Go Implementation
#+BEGIN_SRC go :tangle examples/revocation/go_revocation.go :mkdirp yes
package main

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
)

// Configuration
var (
	secretKey    = getEnv("JWT_SECRET", "your-secret-key")
	redisAddr    = getEnv("REDIS_ADDR", "localhost:6379")
	redisPwd     = getEnv("REDIS_PWD", "")
	redisDB      = 0
	accessTTL    = 15 * time.Minute
	revokePrefix = "revoked_token:"
)

// Custom claims with a family identifier for token revocation
type CustomClaims struct {
	jwt.RegisteredClaims
	Roles       []string          `json:"roles"`
	Permissions []string          `json:"permissions"`
	Family      string            `json:"fam,omitempty"` // Token family identifier
	Metadata    map[string]string `json:"meta,omitempty"`
}

// RevocationService manages token revocation
type RevocationService struct {
	redisClient *redis.Client
	ctx         context.Context
}

// NewRevocationService creates a new token revocation service
func NewRevocationService() *RevocationService {
	redisClient := redis.NewClient(&redis.Options{
		Addr:     redisAddr,
		Password: redisPwd,
		DB:       redisDB,
	})

	return &RevocationService{
		redisClient: redisClient,
		ctx:         context.Background(),
	}
}

// Close closes the Redis connection
func (s *RevocationService) Close() {
	s.redisClient.Close()
}

// IsTokenRevoked checks if a token is revoked
func (s *RevocationService) IsTokenRevoked(tokenID string) (bool, error) {
	key := revokePrefix + tokenID
	val, err := s.redisClient.Exists(s.ctx, key).Result()
	if err != nil {
		return false, fmt.Errorf("failed to check revocation status: %w", err)
	}
	return val > 0, nil
}

// RevokeToken revokes a token by its ID
func (s *RevocationService) RevokeToken(tokenID string, expiresAt time.Time) error {
	key := revokePrefix + tokenID
	// Store until token expiration (to avoid Redis growing indefinitely)
	ttl := time.Until(expiresAt)
	if ttl <= 0 {
		return nil // Already expired, no need to revoke
	}

	_, err := s.redisClient.Set(s.ctx, key, "1", ttl).Result()
	if err != nil {
		return fmt.Errorf("failed to revoke token: %w", err)
	}
	return nil
}

// RevokeTokenFamily revokes all tokens in a family
func (s *RevocationService) RevokeTokenFamily(family string, until time.Time) error {
	key := revokePrefix + "family:" + family
	// Store family revocation with TTL
	ttl := time.Until(until)
	if ttl <= 0 {
		ttl = 24 * 30 * time.Hour // Default to 30 days if until is in the past
	}

	_, err := s.redisClient.Set(s.ctx, key, time.Now().Unix(), ttl).Result()
	if err != nil {
		return fmt.Errorf("failed to revoke token family: %w", err)
	}
	return nil
}

// IsTokenFamilyRevoked checks if a token family is revoked
func (s *RevocationService) IsTokenFamilyRevoked(family string, issuedAt time.Time) (bool, error) {
	key := revokePrefix + "family:" + family
	val, err := s.redisClient.Get(s.ctx, key).Result()
	if err == redis.Nil {
		return false, nil // Not revoked
	}
	if err != nil {
		return false, fmt.Errorf("failed to check family revocation: %w", err)
	}

	// Check if token was issued before revocation
	var revokedAt int64
	if err := json.Unmarshal([]byte(val), &revokedAt); err != nil {
		revokedAt, err = parseInt64(val)
		if err != nil {
			return false, fmt.Errorf("invalid revocation timestamp: %w", err)
		}
	}

	return issuedAt.Before(time.Unix(revokedAt, 0)), nil
}

// TokenService handles JWT token operations
type TokenService struct {
	revocationService *RevocationService
}

// NewTokenService creates a new token service
func NewTokenService(revocationService *RevocationService) *TokenService {
	return &TokenService{
		revocationService: revocationService,
	}
}

// CreateToken generates a new JWT token
func (s *TokenService) CreateToken(userID string, roles, permissions []string) (string, error) {
	now := time.Now()
	expiresAt := now.Add(accessTTL)
	tokenID := uuid.New().String()
	
	// Generate a family identifier for related tokens (useful for revocation)
	family := generateTokenFamily(userID)

	claims := CustomClaims{
		RegisteredClaims: jwt.RegisteredClaims{
			Subject:   userID,
			ExpiresAt: jwt.NewNumericDate(expiresAt),
			IssuedAt:  jwt.NewNumericDate(now),
			NotBefore: jwt.NewNumericDate(now),
			ID:        tokenID,
		},
		Roles:       roles,
		Permissions: permissions,
		Family:      family,
		Metadata: map[string]string{
			"ip": "192.168.1.100", // Would be actual client IP in real app
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	signedToken, err := token.SignedString([]byte(secretKey))
	if err != nil {
		return "", fmt.Errorf("failed to sign token: %w", err)
	}

	return signedToken, nil
}

// VerifyToken verifies and parses a token
func (s *TokenService) VerifyToken(tokenString string) (*CustomClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
		// Verify signing method
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(secretKey), nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to parse token: %w", err)
	}

	if !token.Valid {
		return nil, fmt.Errorf("invalid token")
	}

	claims, ok := token.Claims.(*CustomClaims)
	if !ok {
		return nil, fmt.Errorf("invalid claims type")
	}

	// Check if token is revoked
	isRevoked, err := s.revocationService.IsTokenRevoked(claims.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to check revocation: %w", err)
	}
	if isRevoked {
		return nil, fmt.Errorf("token is revoked")
	}

	// Check if token family is revoked
	if claims.Family != "" {
		isFamilyRevoked, err := s.revocationService.IsTokenFamilyRevoked(
			claims.Family,
			claims.IssuedAt.Time,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to check family revocation: %w", err)
		}
		if isFamilyRevoked {
			return nil, fmt.Errorf("token family is revoked")
		}
	}

	return claims, nil
}

// RevokeToken revokes a specific token
func (s *TokenService) RevokeToken(tokenString string) error {
	token, err := jwt.ParseWithClaims(tokenString, &CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
		return []byte(secretKey), nil
	})

	if err != nil {
		return fmt.Errorf("failed to parse token: %w", err)
	}

	claims, ok := token.Claims.(*CustomClaims)
	if !ok {
		return fmt.Errorf("invalid claims type")
	}

	return s.revocationService.RevokeToken(claims.ID, claims.ExpiresAt.Time)
}

// RevokeAllUserTokens revokes all tokens for a user
func (s *TokenService) RevokeAllUserTokens(userID string) error {
	family := generateTokenFamily(userID)
	// Revoke for 30 days (or longer if needed)
	return s.revocationService.RevokeTokenFamily(
		family,
		time.Now().Add(30*24*time.Hour),
	)
}

// Helper functions

// getEnv gets an environment variable or returns a default
func getEnv(key, fallback string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return fallback
}

// generateTokenFamily creates a unique family identifier for a user
func generateTokenFamily(userID string) string {
	hash := sha256.Sum256([]byte(userID))
	return hex.EncodeToString(hash[:])
}

// parseInt64 parses a string to int64
func parseInt64(s string) (int64, error) {
	var n int64
	_, err := fmt.Sscanf(s, "%d", &n)
	return n, err
}

func main() {
	// Example usage
	revocationService := NewRevocationService()
	defer revocationService.Close()

	tokenService := NewTokenService(revocationService)

	// Create a token
	userID := "user123"
	roles := []string{"user", "admin"}
	permissions := []string{"read:users", "write:users"}

	token, err := tokenService.CreateToken(userID, roles, permissions)
	if err != nil {
		log.Fatalf("Failed to create token: %v", err)
	}
	fmt.Printf("Token created: %s\n\n", token)

	// Verify the token
	claims, err := tokenService.VerifyToken(token)
	if err != nil {
		log.Fatalf("Failed to verify token: %v", err)
	}
	fmt.Printf("Token verified. User: %s, Roles: %v\n\n", claims.Subject, claims.Roles)

	// Revoke the token
	err = tokenService.RevokeToken(token)
	if err != nil {
		log.Fatalf("Failed to revoke token: %v", err)
	}
	fmt.Println("Token revoked")

	// Try to verify the revoked token
	_, err = tokenService.VerifyToken(token)
	fmt.Printf("Verification after revocation: %v\n\n", err)

	// Revoke all user tokens
	err = tokenService.RevokeAllUserTokens(userID)
	if err != nil {
		log.Fatalf("Failed to revoke all user tokens: %v", err)
	}
	fmt.Println("All user tokens revoked")

	// Create a new token and try to verify (should fail due to family revocation)
	newToken, _ := tokenService.CreateToken(userID, roles, permissions)
	_, err = tokenService.VerifyToken(newToken)
	fmt.Printf("Verification of new token after family revocation: %v\n", err)
}
#+END_SRC

*** Ruby Implementation
#+BEGIN_SRC ruby :tangle examples/revocation/ruby_revocation.rb :mkdirp yes
require 'jwt'
require 'redis'
require 'securerandom'
require 'digest'

# Configuration
SECRET_KEY = ENV['JWT_SECRET'] || 'your-secret-key'
REDIS_URL = ENV['REDIS_URL'] || 'redis://localhost:6379/0'
ACCESS_TTL = 15 * 60 # 15 minutes in seconds
REVOKE_PREFIX = 'revoked_token:'

class RevocationService
  def initialize
    @redis = Redis.new(url: REDIS_URL)
  end

  # Check if a token is revoked
  def token_revoked?(token_id)
    key = "#{REVOKE_PREFIX}#{token_id}"
    @redis.exists?(key) == 1
  end

  # Revoke a token by its ID
  def revoke_token(token_id, expires_at)
    key = "#{REVOKE_PREFIX}#{token_id}"
    ttl = expires_at - Time.now.to_i
    return if ttl <= 0 # Already expired, no need to revoke

    @redis.set(key, 1, ex: ttl)
  end

  # Revoke all tokens in a family
  def revoke_token_family(family, until_time = nil)
    until_time ||= Time.now.to_i + (30 * 24 * 60 * 60) # Default to 30 days
    key = "#{REVOKE_PREFIX}family:#{family}"
    ttl = until_time - Time.now.to_i
    ttl = 30 * 24 * 60 * 60 if ttl <= 0 # Default to 30 days if until_time is in the past

    @redis.set(key, Time.now.to_i, ex: ttl)
  end

  # Check if a token family is revoked
  def token_family_revoked?(family, issued_at)
    key = "#{REVOKE_PREFIX}family:#{family}"
    revoked_at = @redis.get(key)
    return false unless revoked_at

    issued_at < revoked_at.to_i
  end
end

class TokenService
  def initialize
    @revocation_service = RevocationService.new
  end

  # Create a new JWT token
  def create_token(user_id, roles, permissions)
    now = Time.now.to_i
    expires_at = now + ACCESS_TTL
    token_id = SecureRandom.uuid
    
    # Generate a family identifier for related tokens
    family = generate_token_family(user_id)

    payload = {
      sub: user_id,
      exp: expires_at,
      iat: now,
      nbf: now,
      jti: token_id,
      roles: roles,
      permissions: permissions,
      fam: family,
      meta: {
        ip: '192.168.1.100', # Would be actual client IP in real app
      }
    }

    JWT.encode(payload, SECRET_KEY, 'HS256')
  end

  # Verify and parse a token
  def verify_token(token_string)
    begin
      decoded_token = JWT.decode(token_string, SECRET_KEY, true, { algorithm: 'HS256' })
      payload = decoded_token[0]
      token_id = payload['jti']

      # Check if token is revoked
      if @revocation_service.token_revoked?(token_id)
        raise JWT::VerificationError, 'Token is revoked'
      end

      # Check if token family is revoked
      family = payload['fam']
      if family && @revocation_service.token_family_revoked?(family, payload['iat'])
        raise JWT::VerificationError, 'Token family is revoked'
      end

      payload
    rescue JWT::ExpiredSignature
      raise 'Token has expired'
    rescue JWT::DecodeError, JWT::VerificationError => e
      raise "Invalid token: #{e.message}"
    end
  end

  # Revoke a specific token
  def revoke_token(token_string)
    begin
      decoded_token = JWT.decode(token_string, SECRET_KEY, true, { algorithm: 'HS256' })
      payload = decoded_token[0]
      token_id = payload['jti']
      expires_at = payload['exp']

      @revocation_service.revoke_token(token_id, expires_at)
    rescue JWT::DecodeError => e
      raise "Failed to parse token: #{e.message}"
    end
  end

  # Revoke all tokens for a user
  def revoke_all_user_tokens(user_id)
    family = generate_token_family(user_id)
    # Revoke for 30 days (or longer if needed)
    @revocation_service.revoke_token_family(family)
  end

  private

  # Generate a unique family identifier for a user
  def generate_token_family(user_id)
    Digest::SHA256.hexdigest(user_id)
  end
end

# Example usage
if __FILE__ == $0
  token_service = TokenService.new

  # Create a token
  user_id = 'user123'
  roles = ['user', 'admin']
  permissions = ['read:users', 'write:users']

  token = token_service.create_token(user_id, roles, permissions)
  puts "Token created: #{token}\n\n"

  # Verify the token
  begin
    claims = token_service.verify_token(token)
    puts "Token verified. User: #{claims['sub']}, Roles: #{claims['roles']}\n\n"
  rescue => e
    puts "Failed to verify token: #{e.message}"
  end

  # Revoke the token
  begin
    token_service.revoke_token(token)
    puts "Token revoked"
  rescue => e
    puts "Failed to revoke token: #{e.message}"
  end

  # Try to verify the revoked token
  begin
    token_service.verify_token(token)
  rescue => e
    puts "Verification after revocation: #{e.message}\n\n"
  end

  # Revoke all user tokens
  begin
    token_service.revoke_all_user_tokens(user_id)
    puts "All user tokens revoked"
  rescue => e
    puts "Failed to revoke all user tokens: #{e.message}"
  end

  # Create a new token and try to verify (should fail due to family revocation)
  new_token = token_service.create_token(user_id, roles, permissions)
  begin
    token_service.verify_token(new_token)
  rescue => e
    puts "Verification of new token after family revocation: #{e.message}"
  end
end
#+END_SRC

* JWT Validation vs. Parsing
:PROPERTIES:
:CUSTOM_ID: validation-vs-parsing
:END:

It's crucial to understand the difference between JWT parsing and validation. Parsing extracts data without verifying integrity, while validation ensures the token is intact and trustworthy.

** Token Parsing (Unsafe)
:PROPERTIES:
:CUSTOM_ID: token-parsing
:END:

Parsing simply decodes the JWT without verifying signatures. This is useful for examining token structure but should NEVER be used for authentication decisions.

*** Python Implementation
#+BEGIN_SRC python :tangle examples/parsing-validation/python_parsing.py :mkdirp yes
import base64
import json

def parse_jwt(token):
    """
    UNSAFE: Parse a JWT without signature verification
    Only use for debugging or examining token structure
    NEVER use for authentication decisions
    """
    # Split the token into parts
    parts = token.split('.')
    if len(parts) != 3:
        raise ValueError("Invalid JWT format")
    
    # Base64url decode the header and payload
    def decode_segment(segment):
        # Add padding if needed
        padding = len(segment) % 4
        if padding:
            segment += '=' * (4 - padding)
        
        # Convert from URL-safe base64 to standard base64
        segment = segment.replace('-', '+').replace('_', '/')
        
        # Decode
        decoded_bytes = base64.b64decode(segment)
        return json.loads(decoded_bytes.decode('utf-8'))
    
    # Parse header and payload
    header = decode_segment(parts[0])
    payload = decode_segment(parts[1])
    
    # Return parsed data (note: signature is NOT verified)
    return {
        'header': header,
        'payload': payload,
        'signature_segment': parts[2],  # Raw, still encoded
        'is_verified': False  # Explicitly mark as unverified
    }

# Example usage
if __name__ == "__main__":
    # Sample token (DO NOT use real tokens in code)
    token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
    
    try:
        # INSECURE - only for demonstration!
        parsed = parse_jwt(token)
        print("⚠️ WARNING: This is unsafe parsing and should NEVER be used for authentication!")
        print(f"Header: {parsed['header']}")
        print(f"Payload: {parsed['payload']}")
    except Exception as e:
        print(f"Error parsing token: {e}")
#+END_SRC

*** TypeScript Implementation
#+BEGIN_SRC typescript :tangle examples/parsing-validation/typescript_parsing.ts :mkdirp yes
/**
 * UNSAFE: Parse a JWT without signature verification
 * Only use for debugging or examining token structure
 * NEVER use for authentication decisions
 */
function parseJwt(token: string): {
  header: any;
  payload: any;
  signatureSegment: string;
  isVerified: boolean;
} {
  // Split the token into parts
  const parts = token.split('.');
  if (parts.length !== 3) {
    throw new Error('Invalid JWT format');
  }

  // Base64url decode function
  const decodeSegment = (segment: string): any => {
    // Add padding if needed
    const padded = segment.padEnd(
      segment.length + (4 - (segment.length % 4)) % 4,
      '='
    );
    
    // Convert from URL-safe base64 to standard base64
    const base64 = padded.replace(/-/g, '+').replace(/_/g, '/');
    
    // Decode
    try {
      const decoded = Buffer.from(base64, 'base64').toString();
      return JSON.parse(decoded);
    } catch (e) {
      throw new Error(`Failed to decode JWT segment: ${e}`);
    }
  };

  // Parse header and payload
  const header = decodeSegment(parts[0]);
  const payload = decodeSegment(parts[1]);

  // Return parsed data (note: signature is NOT verified)
  return {
    header,
    payload,
    signatureSegment: parts[2], // Raw, still encoded
    isVerified: false // Explicitly mark as unverified
  };
}

// Function to demonstrate the dangers of parsing without verification
function demonstrateParsingDanger(): void {
  // Create a completely fake token with admin privileges
  const maliciousHeader = { alg: 'HS256', typ: 'JWT' };
  const maliciousPayload = { 
    sub: 'attacker',
    role: 'admin',
    permissions: ['*'],
    exp: Math.floor(Date.now() / 1000) + 3600
  };

  // Encode to base64url
  const encodeSegment = (obj: any): string => {
    const json = JSON.stringify(obj);
    const base64 = Buffer.from(json).toString('base64');
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
  };

  const fakeToken = `${encodeSegment(maliciousHeader)}.${encodeSegment(maliciousPayload)}.totallyFakeSignature`;
  
  console.log('Fake token created by attacker:', fakeToken);
  
  // UNSAFE parsing - this will "successfully" parse the fake token!
  const parsed = parseJwt(fakeToken);
  console.log('⚠️ DANGER: Parsed payload without verification:', parsed.payload);
  
  console.log('\nThis highlights why you should NEVER rely on parsing alone for authorization decisions.');
}

// Example usage
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";

try {
  // INSECURE - only for demonstration!
  const parsed = parseJwt(token);
  console.log("⚠️ WARNING: This is unsafe parsing and should NEVER be used for authentication!");
  console.log("Header:", parsed.header);
  console.log("Payload:", parsed.payload);
  
  // Demonstrate the dangers
  console.log("\n--- Security Vulnerability Demonstration ---");
  demonstrateParsingDanger();
} catch (e) {
  console.error("Error parsing token:", e);
}
#+END_SRC

** Token Validation (Secure)
:PROPERTIES:
:CUSTOM_ID: token-validation
:END:

Proper validation includes verifying the signature, checking expiration, and validating required claims before trusting the token's contents.

*** Java Implementation
#+BEGIN_SRC java :tangle examples/parsing-validation/java_validation.java :mkdirp yes
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.DecodedJWT;

import java.util.Date;

public class JwtValidator {

    private final String issuer;
    private final String audience;
    private final Algorithm algorithm;

    /**
     * Creates a JWT validator with proper security checks
     *
     * @param secret The secret key used to sign the token
     * @param issuer Expected issuer of the token
     * @param audience Expected audience of the token
     */
    public JwtValidator(String secret, String issuer, String audience) {
        this.issuer = issuer;
        this.audience = audience;
        this.algorithm = Algorithm.HMAC256(secret);
    }

    /**
     * Properly validates a JWT token
     *
     * @param token The JWT token to validate
     * @return The decoded JWT if valid
     * @throws JWTVerificationException if token is invalid
     */
    public DecodedJWT validateToken(String token) throws JWTVerificationException {
        // Create a verifier with all required validations
        JWTVerifier verifier = JWT.require(algorithm)
                .withIssuer(issuer)             // Validate issuer
                .withAudience(audience)         // Validate audience
                .acceptLeeway(5)                // Small leeway for clock skew (5 seconds)
                .build();
        
        // This will throw if the token is invalid
        DecodedJWT jwt = verifier.verify(token);
        
        // Additional validation checks (example)
        validateAdditionalClaims(jwt);
        
        return jwt;
    }
    
    /**
     * Validates custom claims in the token
     */
    private void validateAdditionalClaims(DecodedJWT jwt) throws JWTVerificationException {
        // Example: Ensure token has a subject
        if (jwt.getSubject() == null || jwt.getSubject().isEmpty()) {
            throw new JWTVerificationException("Token missing required subject claim");
        }
        
        // Example: Custom validation based on your requirements
        // e.g., validate permissions, role, or any custom claims
        String role = jwt.getClaim("role").asString();
        if (role == null) {
            throw new JWTVerificationException("Token missing required role claim");
        }
    }

    /**
     * Main method with example usage
     */
    public static void main(String[] args) {
        try {
            // Create a validator
            JwtValidator validator = new JwtValidator(
                    "your-secret-key", 
                    "your-auth-service",
                    "your-api"
            );
            
            // Sample token (in real code, this would come from a request)
            String token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...";
            
            // Validate the token (throws if invalid)
            DecodedJWT jwt = validator.validateToken(token);
            
            // Token is valid - you can now use the claims
            System.out.println("Token is valid!");
            System.out.println("Subject: " + jwt.getSubject());
            System.out.println("Expires at: " + jwt.getExpiresAt());
            System.out.println("Role: " + jwt.getClaim("role").asString());
            
        } catch (JWTVerificationException e) {
            System.err.println("Token validation failed: " + e.getMessage());
        }
    }
}
#+END_SRC

*** Go Implementation
#+BEGIN_SRC go :tangle examples/parsing-validation/go_validation.go :mkdirp yes
package main

import (
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v4"
)

// CustomClaims extends standard JWT claims with your application-specific claims
type CustomClaims struct {
	jwt.RegisteredClaims
	Role        string   `json:"role"`
	Permissions []string `json:"permissions"`
}

// JWTValidator handles JWT validation with proper security checks
type JWTValidator struct {
	secretKey []byte
	issuer    string
	audience  string
}

// NewJWTValidator creates a new JWT validator
func NewJWTValidator(secretKey, issuer, audience string) *JWTValidator {
	return &JWTValidator{
		secretKey: []byte(secretKey),
		issuer:    issuer,
		audience:  audience,
	}
}

// ValidateToken properly validates a JWT token
func (v *JWTValidator) ValidateToken(tokenString string) (*CustomClaims, error) {
	// Parse the token
	token, err := jwt.ParseWithClaims(tokenString, &CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
		// Validate the signing algorithm
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		
		return v.secretKey, nil
	})
	
	if err != nil {
		return nil, fmt.Errorf("token parsing failed: %w", err)
	}
	
	if !token.Valid {
		return nil, fmt.Errorf("invalid token")
	}
	
	claims, ok := token.Claims.(*CustomClaims)
	if !ok {
		return nil, fmt.Errorf("invalid claims type")
	}
	
	// Explicitly validate required claims
	if err := v.validateClaims(claims); err != nil {
		return nil, err
	}
	
	return claims, nil
}

// validateClaims validates the required claims in the token
func (v *JWTValidator) validateClaims(claims *CustomClaims) error {
	now := time.Now()
	
	// Validate expiration
	if claims.ExpiresAt == nil {
		return fmt.Errorf("token missing expiration time")
	}
	if claims.ExpiresAt.Before(now) {
		return fmt.Errorf("token expired")
	}
	
	// Validate issued at
	if claims.IssuedAt == nil {
		return fmt.Errorf("token missing issued at time")
	}
	// Allow 5 minutes of clock skew
	if claims.IssuedAt.After(now.Add(5 * time.Minute)) {
		return fmt.Errorf("token issued in the future")
	}
	
	// Validate issuer
	if claims.Issuer != v.issuer {
		return fmt.Errorf("invalid issuer")
	}
	
	// Validate audience
	if claims.Audience == nil || !claims.Audience.Contains(v.audience) {
		return fmt.Errorf("invalid audience")
	}
	
	// Validate subject
	if claims.Subject == "" {
		return fmt.Errorf("token missing subject")
	}
	
	// Custom validations
	if claims.Role == "" {
		return fmt.Errorf("token missing required role claim")
	}
	
	return nil
}

// UnsafelyExtractClaims demonstrates why parsing without verification is dangerous
// NEVER use this for authentication decisions!
func UnsafelyExtractClaims(tokenString string) (*CustomClaims, error) {
	parts := strings.Split(tokenString, ".")
	if len(parts) != 3 {
		return nil, fmt.Errorf("invalid token format")
	}
	
	// Decode the claims part (middle segment)
	claimBytes, err := jwt.DecodeSegment(parts[1])
	if err != nil {
		return nil, fmt.Errorf("failed to decode claims: %w", err)
	}
	
	var claims CustomClaims
	if err := json.Unmarshal(claimBytes, &claims); err != nil {
		return nil, fmt.Errorf("failed to unmarshal claims: %w", err)
	}
	
	// WARNING: No verification has been performed!
	return &claims, nil
}

// SecurityTestScenarios demonstrates different security test cases
func SecurityTestScenarios() {
	fmt.Println("\n--- SECURITY TEST SCENARIOS ---")
	
	// Create a validator
	validator := NewJWTValidator("your-secret-key", "auth-service", "api-gateway")
	
	// Test case 1: Expired token
	expiredTokenString := createExpiredToken()
	fmt.Println("Testing expired token:")
	if _, err := validator.ValidateToken(expiredTokenString); err != nil {
		fmt.Printf("✅ Security check passed: %s\n", err)
	} else {
		fmt.Println("❌ Security check failed: Accepted expired token!")
	}
	
	// Test case 2: Wrong issuer
	wrongIssuerTokenString := createTokenWithWrongIssuer()
	fmt.Println("\nTesting token with wrong issuer:")
	if _, err := validator.ValidateToken(wrongIssuerTokenString); err != nil {
		fmt.Printf("✅ Security check passed: %s\n", err)
	} else {
		fmt.Println("❌ Security check failed: Accepted token with wrong issuer!")
	}
	
	// Test case 3: None algorithm attack
	noneAlgorithmTokenString := createNoneAlgorithmToken()
	fmt.Println("\nTesting 'none' algorithm attack:")
	if _, err := validator.ValidateToken(noneAlgorithmTokenString); err != nil {
		fmt.Printf("✅ Security check passed: %s\n", err)
	} else {
		fmt.Println("❌ Security check failed: Accepted 'none' algorithm token!")
	}
	
	// Test case 4: Tampered payload
	tamperedTokenString := createTamperedToken()
	fmt.Println("\nTesting tampered token:")
	if _, err := validator.ValidateToken(tamperedTokenString); err != nil {
		fmt.Printf("✅ Security check passed: %s\n", err)
	} else {
		fmt.Println("❌ Security check failed: Accepted tampered token!")
	}
}

func main() {
	// Example usage
	validator := NewJWTValidator("your-secret-key", "auth-service", "api-gateway")
	
	// This would be a token from a request in a real application
	tokenString := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
	
	claims, err := validator.ValidateToken(tokenString)
	if err != nil {
		fmt.Println("Token validation failed:", err)
		return
	}
	
	fmt.Println("Token is valid!")
	fmt.Println("Subject:", claims.Subject)
	fmt.Println("Role:", claims.Role)
	fmt.Println("Permissions:", claims.Permissions)
	
	// Run security test scenarios
	SecurityTestScenarios()
}
#+END_SRC

** Security Recommendations
:PROPERTIES:
:CUSTOM_ID: security-recommendations
:END:

Best practices for implementing JWT validation with robust security.

#+BEGIN_SRC markdown :tangle examples/parsing-validation/security_recommendations.md :mkdirp yes
# JWT Security Recommendations

## Always Validate Before Using

1. **Verify signatures first** - Never trust token contents before signature verification
2. **Check all required claims** - Validate expiration, issuer, audience, and subject
3. **Validate token type** - Ensure the token is used for its intended purpose
4. **Be mindful of algorithm selection** - Prefer strong algorithms like RS256 over HS256 when possible
5. **Use libraries correctly** - Follow library documentation and security advisories

## Common JWT Attacks to Defend Against

### None Algorithm Attack

The attacker modifies the JWT header to use the "none" algorithm, indicating the token doesn't need a signature:

```json
{
  "alg": "none",
  "typ": "JWT"
}
```

**Defense**: Always validate the algorithm and reject "none" algorithm tokens.

### Algorithm Confusion Attack

The attacker tricks the system into verifying a token signed with one algorithm (like RS256) using another (like HS256):

**Defense**: Always explicitly validate the algorithm in the token matches the expected algorithm.

### Token Injection

The attacker uses a token from one context in another:

**Defense**: Validate the token's audience (`aud`) claim matches your service.

### Replay Attacks

The attacker captures a valid token and reuses it:

**Defense**: Use short expiration times, implement token revocation, and consider using nonces for critical operations.

## Implementation Checklist

- [ ] Use a reputable JWT library
- [ ] Verify signatures before accessing payload
- [ ] Validate all required claims (iss, sub, exp, iat, aud)
- [ ] Implement token revocation for sensitive systems
- [ ] Use secure key management (HSM for production)
- [ ] Apply the principle of least privilege for token permissions
- [ ] Add monitoring for suspicious JWT usage patterns
- [ ] Document token validation requirements for developers

## Code Review Checklist

When reviewing JWT code, look for:

- Signature verification before payload access
- Explicit validation of all relevant claims
- Proper error handling for invalid tokens
- No use of unsafe parsing functions
- Secure key management
- Appropriate token lifetime settings
#+END_SRC

* Project Metadata
:PROPERTIES:
:CUSTOM_ID: metadata
:END:

#+BEGIN_SRC org :tangle metadata.org :mkdirp yes
#+TITLE: JWT Advanced Examples Repository
#+AUTHOR: Aidan Pace
#+EMAIL: apace@defrecord.com
#+DATE: [2025-04-28]

* Project Information

- *GitHub Repository*: https://github.com/aygp-dr/jwt-parsing-examples
- *Project Lead*: Aidan Pace (@aygp-dr)
- *Contact*: apace@defrecord.com
- *License*: MIT License

* Presentation History

This codebase has been presented at:
- SPLASH 2025 (Chicago, IL)
- StrangeLoop 2025 (St. Louis, MO)
- PyConf 2025 (Pittsburgh, PA)
- EuroLISP 2025 (Berlin, Germany)

* Contributions

Contributions are welcome! Please see CONTRIBUTING.md for guidelines.
#+END_SRC

* Mermaid Diagrams
:PROPERTIES:
:CUSTOM_ID: diagrams
:END:

** JWT Flow Diagram
#+BEGIN_SRC mermaid :file diagrams/jwt-flow.png :mkdirp yes
sequenceDiagram
    participant User
    participant Auth as Authentication Service
    participant API as API Gateway
    participant Resource as Resource Server
    participant Redis as Token Store (Redis)
    
    User->>Auth: Login (username, password)
    Auth->>Auth: Validate credentials
    Auth->>Redis: Store refresh token metadata
    Auth->>User: Return access token + refresh token
    
    User->>API: Request + access token
    API->>API: Parse JWT header
    API->>API: Verify token signature
    API->>Redis: Check token revocation (if applicable)
    API->>Resource: Forward request
    Resource->>User: Response
    
    Note over User,Auth: Token Refresh Flow
    User->>Auth: refresh_token
    Auth->>Redis: Validate refresh token
    Auth->>Auth: Generate new access token
    Auth->>User: Return new access token
    
    Note over User,Auth: Logout Flow
    User->>Auth: refresh_token
    Auth->>Redis: Revoke refresh token
    Auth->>User: Logout confirmation
#+END_SRC

** Token Revocation Diagram
#+BEGIN_SRC mermaid :file diagrams/token-revocation.png :mkdirp yes
flowchart TD
    A[Client] -->|1. Request with token| B[API Gateway]
    B -->|2. Extract JWT| C{Is token valid?}
    
    C -->|Yes| D{Check Redis}
    C -->|No: Expired| R[Reject Request]
    
    D -->|1. Get token ID| E[Check revoked_token:id]
    D -->|2. Get token family| F[Check revoked_token:family:id]
    
    E -->|exists?| G{Token Revoked?}
    F -->|issued_at < revoked_at?| H{Family Revoked?}
    
    G -->|Yes| R
    G -->|No| I{Continue checks}
    
    H -->|Yes| R
    H -->|No| J[Allow Request]
    
    I -->|All clear| J
    
    subgraph Redis DB
    E
    F
    end
    
    subgraph "Revocation Events"
    K[User Logout] -->|Revoke token| E
    L[Password Change] -->|Revoke family| F
    M[Security Event] -->|Revoke families| F
    end
#+END_SRC

** Refresh Token Flow
#+BEGIN_SRC mermaid :file diagrams/refresh-flow.png :mkdirp yes
sequenceDiagram
    participant Client
    participant Auth as Auth Service
    participant Redis as Token Store
    participant DB as User Database
    
    Client->>Auth: Login Request
    Auth->>DB: Verify Credentials
    DB->>Auth: User Details
    
    Auth->>Auth: Generate Access Token
    Auth->>Auth: Generate Refresh Token
    
    Auth->>Redis: Store refresh_token:{jti} = { user_id, revoked: false }
    Auth->>Client: Access Token + Refresh Token
    
    Note over Client,Auth: Later when access token expires
    
    Client->>Auth: Refresh Request (Refresh Token)
    Auth->>Auth: Decode Refresh Token
    Auth->>Redis: Get refresh_token:{jti}
    
    alt Token Valid & Not Revoked
        Redis->>Auth: { user_id, revoked: false }
        Auth->>DB: Get Latest User Data
        DB->>Auth: Updated Permissions/Roles
        Auth->>Auth: Generate New Access Token
        Auth->>Client: New Access Token
    else Token Revoked
        Redis->>Auth: { user_id, revoked: true }
        Auth->>Client: 401 Unauthorized
    else Token Not Found
        Redis->>Auth: nil (not found)
        Auth->>Client: 401 Unauthorized
    end
    
    Note over Client,Auth: During logout
    
    Client->>Auth: Logout (Refresh Token)
    Auth->>Auth: Decode Refresh Token
    Auth->>Redis: Update refresh_token:{jti} = { revoked: true }
    Auth->>Client: Logout Successful
#+END_SRC
