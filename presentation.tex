% Created 2025-04-30 Wed 03:06
% Intended LaTeX compiler: pdflatex
\documentclass[presentation,aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usetheme{metropolis}
\usecolortheme{default}
\author{Aidan Pace}
\date{\textit{{[}2025-04-28 Mon]}}
\title{Parsing JWT Headers Across Programming Paradigms}
\AtBeginSection[]{\begin{frame}<beamer>\frametitle{Agenda}\tableofcontents[currentsection]\end{frame}}
\hypersetup{
 pdfauthor={Aidan Pace},
 pdftitle={Parsing JWT Headers Across Programming Paradigms},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 31.0.50 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\begin{frame}[label={sec:org098aec0}]{Introduction}
\begin{block}{Parsing JWT Headers Across Programming Paradigms}
\begin{itemize}[<+->]
\item A cross-language exploration of JWT header parsing techniques
\item SPLASH/StrangeLoop/PyConf/RacketCon/EuroLISP 2025
\item Aidan Pace (@aygp-dr)
\end{itemize}
\end{block}
\begin{block}{What We'll Cover}
\begin{itemize}[<+->]
\item Historical context and authentication evolution
\item JWT structure and fundamentals (üî∞ beginner-friendly)
\item Base64url encoding challenges
\item Header parsing patterns across languages
\item Functional vs object-oriented approaches
\item Language-specific idioms and best practices
\item Security considerations and common attacks
\item Performance analysis and real-world applications
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org1fb45f0}]{Authentication Evolution}
\begin{block}{Historical Context of Authentication}
\begin{itemize}[<+->]
\item Early authentication: Username/password pairs
\item Server-side sessions with cookies (stateful)
\item Token-based authentication emergence (stateless)
\item JWT standardization (RFC 7519, May 2015)
\item Modern authentication flows (OAuth 2.0, OIDC)
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org9be340e},fragile]{JWT Basics}
 \begin{block}{JWT Structure Refresher üî∞}
\begin{verbatim}
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
\end{verbatim}

Three dot-separated base64url-encoded segments:
\begin{enumerate}
\item \alert{Header} (algorithm \& token type)
\item \alert{Payload} (claims)
\item \alert{Signature}
\end{enumerate}

\begin{verbatim}
digraph {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor="#e6f3ff", fontname="monospace"];
  edge [fontname="Arial"];

  Header [label="Header\n{\"alg\":\"HS256\",\n\"typ\":\"JWT\"}"];
  Payload [label="Payload\n{\"sub\":\"1234\",\n\"name\":\"User\",\n\"exp\":1516239022}"];
  Signature [label="Signature\nHMAC-SHA256(\n  base64UrlEncode(header) + '.' +\n  base64UrlEncode(payload),\n  secret\n)"];

  Header -> Payload [label="  .  "];
  Payload -> Signature [label="  .  "];
}
\end{verbatim}
\end{block}
\begin{block}{JWT Claims \& Use Cases üî∞}
\alert{Standard Claims:}
\begin{itemize}
\item \texttt{iss} - Issuer (who created the token)
\item \texttt{sub} - Subject (whom the token refers to)
\item \texttt{aud} - Audience (who should accept the token)
\item \texttt{exp} - Expiration time
\item \texttt{nbf} - Not before time
\item \texttt{iat} - Issued at time
\item \texttt{jti} - JWT ID (unique identifier)
\end{itemize}

\alert{Common Use Cases:}
\begin{itemize}
\item Authentication after login
\item API authorization
\item Information exchange between services
\item Single Sign-On (SSO)
\end{itemize}
\end{block}
\begin{block}{The Base64url Challenge}
Standard Base64 vs Base64url encoding:
\begin{itemize}
\item URL-safe variant replaces \texttt{+} with \texttt{-} and \texttt{/} with \texttt{\_}
\item Padding (\texttt{=} ) often omitted
\item Used to ensure tokens can be safely transmitted in URLs
\end{itemize}

\alert{Every language handles this differently!}
\end{block}
\end{frame}
\begin{frame}[label={sec:org522ed70},fragile]{Language Implementations}
 \begin{block}{JavaScript (Browser) üß©}
\begin{verbatim}
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANT: In production, verify signature before parsing!
// This example is for demonstration only

// Decode the header part
const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(atob(headerPart));
console.log(decodedHeader);
\end{verbatim}

\alert{Note}: \texttt{atob()} handles base64 but not base64url specifically
\end{block}
\begin{block}{Node.js üß©}
\begin{verbatim}
// Using built-in modules
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANT: In production, verify signature before parsing!
// This example is for demonstration only

const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(
  Buffer.from(headerPart, 'base64').toString()
);
console.log(decodedHeader);
\end{verbatim}
\end{block}
\begin{block}{TypeScript with Type Safety üß©}
\begin{verbatim}
interface JwtHeader {
  alg: string;
  typ: string;
  kid?: string;  // Key identifier, optional
}

function decodeJwtHeader(authHeader: string): JwtHeader {
  const token: string = authHeader.split(' ')[1];
  const headerPart: string = token.split('.')[0];

  // IMPORTANT: In production, verify signature before parsing!
  // This example is for demonstration only

  // Add padding if needed
  const base64 = headerPart.replace(/-/g, '+').replace(/_/g, '/');
  const padded = base64.padEnd(base64.length + (4 - (base64.length % 4)) % 4, '=');

  const decodedHeader: JwtHeader = JSON.parse(
    Buffer.from(padded, 'base64').toString()
  );
  return decodedHeader;
}
\end{verbatim}
\end{block}
\begin{block}{Python Implementation üß©}
\begin{verbatim}
import base64
import json
import typing

def decode_jwt_header(auth_header: str) -> typing.Dict[str, str]:
    """Decode JWT header from Authorization header.

    IMPORTANT: In production, verify signature before parsing!
    This example is for demonstration only.
    """
    token = auth_header.split(' ')[1]
    header_part = token.split('.')[0]

    # Add padding if needed
    padding_needed = len(header_part) % 4
    if padding_needed:
        header_part += '=' * (4 - padding_needed)

    # Decode base64
    decoded_bytes = base64.b64decode(header_part.replace('-', '+').replace('_', '/'))
    decoded_str = decoded_bytes.decode('utf-8')

    # Parse JSON
    return json.loads(decoded_str)
\end{verbatim}
\end{block}
\begin{block}{Functional Approaches: Clojure üß©}
\begin{verbatim}
;; IMPORTANT: In production, verify signature before parsing!
;; This example is for demonstration only.
(defn decode-jwt-header 
  "Decode JWT header from Authorization header."
  [auth-header]
  (let [token (second (clojure.string/split auth-header #" "))
        header-part (first (clojure.string/split token #"\."))
        decoder (Base64/getUrlDecoder)
        decoded-bytes (.decode decoder header-part)
        decoded-str (String. decoded-bytes)
        header (json/read-str decoded-str)]
    header))
\end{verbatim}

\alert{Note}: JVM's Base64 has a URL decoder built-in!
\end{block}
\begin{block}{Functional Approaches: Racket ‚ö†Ô∏è}
\begin{verbatim}
;; Convert base64url to standard base64 and decode
(define (base64url->bytes str)
  (define padding (make-string (modulo (- 0 (string-length str)) 4) #\=))
  (define base64 (string-map (Œª (c)
                               (match c
                                 [#\- #\+]
                                 [#\_ #\/]
                                 [_ c]))
                             str))
  (base64-decode (string-append base64 padding)))

;; IMPORTANT: In production, verify signature before parsing!
;; This example is for demonstration only and uses functional composition
(define (decode-jwt-header auth-header)
  ;; Pipeline of transformations
  (define token (second (string-split auth-header)))
  (define header-part (first (string-split token ".")))
  (define decoded-bytes (base64url->bytes header-part))
  (define decoded-str (bytes->string/utf-8 decoded-bytes))
  (string->jsexpr decoded-str))
\end{verbatim}
\end{block}
\begin{block}{Low-Level Implementation: Rust ‚ö†Ô∏è}
\begin{verbatim}
#[derive(Debug, Serialize, Deserialize)]
struct JwtHeader {
    alg: String,
    typ: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    kid: Option<String>,  // Optional key identifier
}

/// Decode JWT header from Authorization header
/// 
/// # IMPORTANT
/// In production, verify signature before parsing!
/// This example is for demonstration only.
/// 
/// # Error Handling
/// Returns Result with either parsed header or descriptive error
fn decode_jwt_header(auth_header: &str) -> Result<JwtHeader, Box<dyn std::error::Error>> {
    // Extract token with error handling
    let token = auth_header.split_whitespace().nth(1).ok_or("Invalid auth header")?;
    let header_part = token.split('.').next().ok_or("Invalid token format")?;

    // Decode base64url to bytes (using proper URL-safe decoder)
    let decoded_bytes = general_purpose::URL_SAFE_NO_PAD.decode(header_part)?;

    // Parse JSON with strong typing
    let header: JwtHeader = serde_json::from_slice(&decoded_bytes)?;
    Ok(header)
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:org9ebcdd3},fragile]{Analysis}
 \begin{block}{Common Patterns \& Variations üß©}
\begin{enumerate}[<+->]
\item \alert{Token extraction}: Split by space or regex
\item \alert{Base64url handling}:
\begin{itemize}
\item Character replacement (\texttt{-} ‚Üí \texttt{+}, \texttt{\_} ‚Üí \texttt{/})
\item Padding calculation
\item URL-safe decoder availability (JVM advantage)
\end{itemize}
\item \alert{JSON parsing}: Native vs libraries
\item \alert{Error handling}: Idiomatic differences
\end{enumerate}
\end{block}
\begin{block}{Cross-Language Performance Analysis ‚ö†Ô∏è}
\begin{center}
\begin{tabular}{lrr}
Language & Parsing Time (Œºs) & Memory Usage (KB)\\
\hline
Rust & 5.2 & 1.8\\
JavaScript & 24.7 & 12.3\\
Python & 30.1 & 15.7\\
Clojure & 45.8 & 28.4\\
Shell & 180.3 & 8.9\\
\end{tabular}
\end{center}

\alert{Note: Average of 1000 runs, single-threaded}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgeb1f650},fragile]{Security Considerations}
 \begin{block}{JWT Security Best Practices ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{Always verify signatures before parsing or using payload}
\item Use strong algorithms (prefer RS256/ES256 over HS256)
\item Implement proper key management (rotation, secure storage)
\item Set appropriate token lifetimes (short-lived access tokens)
\item Include essential claims (iss, sub, exp, aud, iat)
\end{itemize}
\end{block}
\begin{block}{Common JWT Attacks ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{"alg": "none" attack} - Attacker removes signature validation requirement
\item \alert{Algorithm confusion} - Switching from asymmetric (RS256) to symmetric (HS256)
\item \alert{Token tampering} - Modifying claims without invalidating signature
\item \alert{Token injection} - Using a token from one context in another
\item \alert{Replay attacks} - Reusing captured tokens
\end{itemize}
\end{block}
\begin{block}{Token Lifecycle Management ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{Refresh token patterns} - Securely obtain new access tokens
\item \alert{Token revocation} - Invalidate tokens before expiration
\item \alert{Token validation pipeline} - Proper order of operations
\item \alert{Blacklisting} - Tracking compromised or logged-out tokens
\end{itemize}

\begin{verbatim}
digraph {
  node [shape=box, style=filled, fillcolor="#f5f5f5"];
  edge [fontname="Arial"];

  issue [label="Token Issuance", fillcolor="#e6ffe6"];
  validate [label="Token Validation", fillcolor="#e6f3ff"];
  refresh [label="Token Refresh", fillcolor="#fff0e6"];
  revoke [label="Token Revocation", fillcolor="#ffe6e6"];

  issue -> validate -> refresh -> validate;
  validate -> revoke;
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:org546e26c},fragile]{Real-World Applications}
 \begin{block}{Cross-Language Implementation Comparison}
\begin{center}
\begin{tabular}{llllll}
Feature & JavaScript & Python & Rust & Clojure & TypeScript\\
\hline
Type Safety & Limited & Optional & Strong & Dynamic & Strong\\
Base64 Handling & Manual & Built-in & Crates & JVM & Manual\\
Error Handling & try/catch & Exceptions & Result & Monadic & try/catch\\
Performance & Medium & Low & High & Medium & Medium\\
JWT Libraries & Many & Several & Few & Few & Many\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{JWT in Production}
\begin{itemize}[<+->]
\item API Gateway token validation
\item Microservice authorization
\item Single Sign-On implementations
\item Mobile app authentication
\item Server-to-server communication
\end{itemize}
\end{block}
\begin{block}{JWT Flow}
\begin{verbatim}
digraph {
  rankdir=LR;
  node [shape=box, style=rounded];
  subgraph cluster_validation {
    label="Secure Validation Process";
    style=dashed;
    color=gray;
    "Extract JWT" -> "Verify Signature" -> "Validate Claims" -> "Check Revocation";
  }

  Client -> "Auth Service" [label="1. Login"];
  "Auth Service" -> Client [label="2. JWT"];
  Client -> "API Gateway" [label="3. Request + JWT"];
  "API Gateway" -> "Extract JWT";
  "Check Revocation" -> "Microservice" [label="4. Authorized Request"];
  "Microservice" -> Client [label="5. Response"];
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:orga51283f}]{Debugging \& Troubleshooting}
\begin{block}{Common JWT Issues and Solutions}
\begin{itemize}[<+->]
\item \alert{Invalid signature} - Check key matching, algorithm consistency
\item \alert{Expired tokens} - Verify client/server clock synchronization
\item \alert{Malformed tokens} - Inspect encoding, ensure proper base64url handling
\item \alert{Missing claims} - Validate token structure against expected schema
\item \alert{Algorithm mismatch} - Confirm header alg matches implementation
\end{itemize}
\end{block}
\begin{block}{Debugging Tools}
\begin{itemize}[<+->]
\item Online JWT debugger (jwt.io)
\item Language-specific JWT libraries with debug options
\item Base64 inspection tools
\item Request/response inspection with developer tools
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgab55db2},fragile]{Conclusion}
 \begin{block}{Cross-Paradigm Insights}
\begin{center}
\begin{tabular}{lll}
Paradigm & Strengths & JWT Application\\
\hline
Object-Oriented & Encapsulation, inheritance & Token with validation methods\\
Functional & Composition, immutability & Transform pipeline for parsing\\
Procedural & Simplicity, performance & Lightweight validators\\
Reactive & Event handling & Token verification in async flows\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{Takeaways}
\begin{enumerate}[<+->]
\item Base64url encoding requires special attention
\item Each language has idiomatic parsing advantages
\item Functional approaches shine for transformation pipelines
\item Security first: always verify signatures before parsing
\item Consider token lifecycle for complete implementation
\item Libraries save time but understanding internals matters
\item Follow language-specific best practices
\end{enumerate}
\end{block}
\begin{block}{Learning Resources}
\begin{itemize}[<+->]
\item JWT RFC 7519: \url{https://tools.ietf.org/html/rfc7519}
\item JWT Security Best Practices (IETF): \url{https://datatracker.ietf.org/doc/html/draft-ietf-oauth-jwt-bcp}
\item OWASP JWT Cheat Sheet: \url{https://cheatsheetseries.owasp.org/cheatsheets/JSON\_Web\_Token\_for\_Java\_Cheat\_Sheet.html}
\item Language-specific security guides: see repository docs
\end{itemize}
\end{block}
\begin{block}{JWT Glossary for Beginners üî∞}
\begin{center}
\begin{tabular}{ll}
Term & Definition\\
\hline
JWT & JSON Web Token: a compact, URL-safe means of representing claims to be transferred between parties\\
Claims & Pieces of information asserted about a subject (e.g., user ID, expiration time)\\
Base64url & A URL-safe variant of Base64 encoding that can be included in URLs without escaping\\
Header & First part of JWT containing metadata like algorithm used for signing\\
Payload & Second part of JWT containing the actual claims data\\
Signature & Third part of JWT that verifies the token hasn't been altered\\
HMAC & Hash-based Message Authentication Code: technique for ensuring data integrity using a secret key\\
RSA & Public-key cryptosystem commonly used for JWT signatures\\
Stateless & Authentication not requiring server-side session storage\\
Bearer token & Type of access token where possession of the token is sufficient for authentication\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{Python Security Best Practices ‚ö†Ô∏è}
\begin{verbatim}
import jwt
from cryptography.hazmat.primitives.constant_time import bytes_eq
from typing import Dict, Any, Optional, List, Union

# Define explicit typing for JWT claims
class JWTClaims(TypedDict):
    iss: str  # issuer
    sub: str  # subject
    exp: int  # expiration time
    iat: int  # issued at time
    aud: Optional[Union[str, List[str]]]  # audience

def verify_and_decode_token(token: str, key: str, algorithms: List[str] = ['RS256']) -> JWTClaims:
    """Securely verify and decode a JWT token with proper error handling.

    IMPORTANT: This function validates the signature BEFORE processing payload.
    """
    try:
        # Explicitly specify allowed algorithms (prevent 'none' algorithm attack)
        # Validate signature first, then decode payload
        payload = jwt.decode(
            token,
            key,
            algorithms=algorithms,  # Explicitly specify allowed algorithms
            options={"verify_signature": True}
        )
        return payload
    except jwt.ExpiredSignatureError:
        # Specific exception for expired token
        raise ValueError("Token has expired")
    except jwt.InvalidSignatureError:
        # Use generic error that doesn't reveal signature details
        raise ValueError("Authentication failed")
    except jwt.DecodeError:
        # Generic decode error
        raise ValueError("Invalid token")
    except jwt.InvalidAlgorithmError:
        raise ValueError("Invalid token algorithm")
    except Exception:
        # Catch-all with generic message to avoid information leakage
        raise ValueError("Authentication failed")
\end{verbatim}
\end{block}
\begin{block}{Functional Pipelines: Enhanced Clojure Example üß©}
\begin{verbatim}
;; Leveraging Clojure's functional approach with thread-first macro
;; for cleaner transformation pipeline

(defn decode-base64url
  "Decode base64url-encoded string to string"
  [base64url-str]
  (-> base64url-str
      (java.util.Base64/getUrlDecoder)
      (.decode)
      (String.)))

(defn extract-token
  "Extract token from auth header"
  [auth-header]
  (-> auth-header
      (clojure.string/split #" ")
      (second)))

(defn extract-header-part
  "Extract header part from token"
  [token]
  (-> token
      (clojure.string/split #"\.")
      (first)))

(defn parse-json
  "Parse JSON string to Clojure map"
  [json-str]
  (json/read-str json-str :key-fn keyword))

;; IMPORTANT: In production, verify signature before parsing!
;; This example demonstrates functional composition for readability
(defn decode-jwt-header
  "Extract and decode JWT header using a functional pipeline"
  [auth-header]
  (-> auth-header
      (extract-token)
      (extract-header-part)
      (decode-base64url)
      (parse-json)))
\end{verbatim}
\end{block}
\begin{block}{Questions?}
Thank you!

\alert{Slides \& examples available at:} 
github.com/aidan-pace/jwt-parsing-examples

\alert{Difficulty levels:} üî∞ Beginner | üß© Intermediate | ‚ö†Ô∏è Advanced
\end{block}
\end{frame}
\end{document}
