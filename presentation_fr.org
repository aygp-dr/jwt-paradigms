#+TITLE: Analyse des en-t√™tes JWT √† travers les paradigmes de programmation
#+AUTHOR: Aidan Pace
#+EMAIL: apace@defrecord.com
#+DATE: [2025-04-28]
#+LANGUAGE: fr
#+OPTIONS: toc:nil num:nil ^:nil
#+STARTUP: beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation,aspectratio=169]
#+BEAMER_THEME: metropolis
#+BEAMER_COLOR_THEME: default
#+BEAMER_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Agenda}\tableofcontents[currentsection]\end{frame}}

* Introduction
** Analyse des en-t√™tes JWT √† travers les paradigmes de programmation
#+ATTR_BEAMER: :overlay <+->
- Une exploration inter-langages des techniques d'analyse des en-t√™tes JWT
- PyCon US 2025, 14 mai - 22 mai 2025
- Aidan Pace (@aygp-dr)

** Ce que nous allons couvrir
#+ATTR_BEAMER: :overlay <+->
- Contexte historique et √©volution de l'authentification
- Structure JWT et fondamentaux (üî∞ adapt√© aux d√©butants)
- D√©fis de l'encodage Base64url
- Mod√®les d'analyse d'en-t√™tes dans diff√©rents langages
- Approches fonctionnelles vs. orient√©es objet
- Idiomes et bonnes pratiques sp√©cifiques aux langages
- Consid√©rations de s√©curit√© et attaques courantes
- Analyse des performances et applications r√©elles

* √âvolution de l'authentification
** Contexte historique de l'authentification
#+ATTR_BEAMER: :overlay <+->
- Authentification primitive : Paires nom d'utilisateur/mot de passe
- Sessions c√¥t√© serveur avec cookies (avec √©tat)
- √âmergence de l'authentification par jetons (sans √©tat)
- Standardisation JWT (RFC 7519, mai 2015)
- Flux d'authentification modernes (OAuth 2.0, OIDC)

* Bases de JWT
** Rappel de la structure JWT üî∞
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
#+END_SRC

Trois segments encod√©s en base64url s√©par√©s par des points :
1. *En-t√™te* (algorithme et type de jeton)
2. *Charge utile* (revendications/claims)
3. *Signature*

#+BEGIN_SRC dot :file images/jwt-structure.png :cmdline -Kdot -Tpng
digraph {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor="#e6f3ff", fontname="monospace"];
  edge [fontname="Arial"];
  
  Header [label="En-t√™te\n{\"alg\":\"HS256\",\n\"typ\":\"JWT\"}"];
  Payload [label="Charge utile\n{\"sub\":\"1234\",\n\"name\":\"User\",\n\"exp\":1516239022}"];
  Signature [label="Signature\nHMAC-SHA256(\n  base64UrlEncode(header) + '.' +\n  base64UrlEncode(payload),\n  secret\n)"];
  
  Header -> Payload [label="  .  "];
  Payload -> Signature [label="  .  "];
}
#+END_SRC

** Revendications JWT et cas d'utilisation üî∞
#+ATTR_BEAMER: :overlay <+->
*Revendications standard :*
- =iss= - √âmetteur (qui a cr√©√© le jeton)
- =sub= - Sujet (√† qui le jeton fait r√©f√©rence)
- =aud= - Audience (qui devrait accepter le jeton)
- =exp= - Temps d'expiration
- =nbf= - Pas avant (ce temps)
- =iat= - √âmis √† (ce temps)
- =jti= - ID JWT (identifiant unique)

*Cas d'utilisation courants :*
- Authentification apr√®s connexion
- Autorisation d'API
- √âchange d'informations entre services
- Authentification unique (SSO)

** Le d√©fi Base64url
#+ATTR_BEAMER: :overlay <+->
Base64 standard vs encodage Base64url :
- La variante URL-safe remplace =+= par =-= et =/= par =_=
- Le rembourrage (=== ) est souvent omis
- Utilis√© pour garantir que les jetons peuvent √™tre transmis en toute s√©curit√© dans les URL

*Chaque langage g√®re cela diff√©remment !*

* Impl√©mentations dans diff√©rents langages
** JavaScript (Navigateur) üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC javascript
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
// Cet exemple est uniquement √† des fins de d√©monstration

// D√©codage de la partie en-t√™te
const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(atob(headerPart));
console.log(decodedHeader);
#+END_SRC

*Remarque* : =atob()= g√®re base64 mais pas sp√©cifiquement base64url

** Node.js üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC javascript
// Utilisation des modules int√©gr√©s
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
// Cet exemple est uniquement √† des fins de d√©monstration

const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(
  Buffer.from(headerPart, 'base64').toString()
);
console.log(decodedHeader);
#+END_SRC

** TypeScript avec s√ªret√© du typage üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC typescript
interface JwtHeader {
  alg: string;
  typ: string;
  kid?: string;  // Identifiant de cl√©, optionnel
}

function decodeJwtHeader(authHeader: string): JwtHeader {
  const token: string = authHeader.split(' ')[1];
  const headerPart: string = token.split('.')[0];
  
  // IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
  // Cet exemple est uniquement √† des fins de d√©monstration
  
  // Ajout de rembourrage si n√©cessaire
  const base64 = headerPart.replace(/-/g, '+').replace(/_/g, '/');
  const padded = base64.padEnd(base64.length + (4 - (base64.length % 4)) % 4, '=');
  
  const decodedHeader: JwtHeader = JSON.parse(
    Buffer.from(padded, 'base64').toString()
  );
  return decodedHeader;
}
#+END_SRC

** Impl√©mentation Python üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC python
import base64
import json
import typing

def decode_jwt_header(auth_header: str) -> typing.Dict[str, str]:
    """D√©code l'en-t√™te JWT √† partir de l'en-t√™te d'autorisation.
    
    IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
    Cet exemple est uniquement √† des fins de d√©monstration.
    """
    token = auth_header.split(' ')[1]
    header_part = token.split('.')[0]
    
    # Ajout de rembourrage si n√©cessaire
    padding_needed = len(header_part) % 4
    if padding_needed:
        header_part += '=' * (4 - padding_needed)
    
    # D√©codage base64
    decoded_bytes = base64.b64decode(header_part.replace('-', '+').replace('_', '/'))
    decoded_str = decoded_bytes.decode('utf-8')
    
    # Analyse JSON
    return json.loads(decoded_str)
#+END_SRC

** Approches fonctionnelles : Clojure üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC clojure
;; IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
;; Cet exemple est uniquement √† des fins de d√©monstration.
(defn decode-jwt-header 
  "D√©code l'en-t√™te JWT √† partir de l'en-t√™te d'autorisation."
  [auth-header]
  (let [token (second (clojure.string/split auth-header #" "))
        header-part (first (clojure.string/split token #"\."))
        decoder (Base64/getUrlDecoder)
        decoded-bytes (.decode decoder header-part)
        decoded-str (String. decoded-bytes)
        header (json/read-str decoded-str)]
    header))
#+END_SRC

*Remarque* : Base64 de la JVM poss√®de un d√©codeur URL int√©gr√© !

** Approches fonctionnelles : Racket ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC racket
;; Convertir base64url en base64 standard et d√©coder
(define (base64url->bytes str)
  (define padding (make-string (modulo (- 0 (string-length str)) 4) #\=))
  (define base64 (string-map (Œª (c)
                               (match c
                                 [#\- #\+]
                                 [#\_ #\/]
                                 [_ c]))
                             str))
  (base64-decode (string-append base64 padding)))

;; IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
;; Cet exemple est uniquement √† des fins de d√©monstration et utilise la composition fonctionnelle
(define (decode-jwt-header auth-header)
  ;; Pipeline de transformations
  (define token (second (string-split auth-header)))
  (define header-part (first (string-split token ".")))
  (define decoded-bytes (base64url->bytes header-part))
  (define decoded-str (bytes->string/utf-8 decoded-bytes))
  (string->jsexpr decoded-str))
#+END_SRC

** Impl√©mentation de bas niveau : Rust ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC rust
#[derive(Debug, Serialize, Deserialize)]
struct JwtHeader {
    alg: String,
    typ: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    kid: Option<String>,  // Identifiant de cl√© optionnel
}

/// D√©code l'en-t√™te JWT √† partir de l'en-t√™te d'autorisation
/// 
/// # IMPORTANT
/// En production, v√©rifiez la signature avant l'analyse !
/// Cet exemple est uniquement √† des fins de d√©monstration.
/// 
/// # Gestion des erreurs
/// Renvoie Result avec soit l'en-t√™te analys√©, soit une erreur descriptive
fn decode_jwt_header(auth_header: &str) -> Result<JwtHeader, Box<dyn std::error::Error>> {
    // Extraction du jeton avec gestion des erreurs
    let token = auth_header.split_whitespace().nth(1).ok_or("En-t√™te d'auth invalide")?;
    let header_part = token.split('.').next().ok_or("Format de jeton invalide")?;
    
    // D√©codage base64url en octets (avec d√©codeur URL s√©curis√© appropri√©)
    let decoded_bytes = general_purpose::URL_SAFE_NO_PAD.decode(header_part)?;
    
    // Analyse JSON avec typage fort
    let header: JwtHeader = serde_json::from_slice(&decoded_bytes)?;
    Ok(header)
}
#+END_SRC

* Analyse
** Mod√®les communs et variations üß©
#+ATTR_BEAMER: :overlay <+->
1. *Extraction de jeton* : Division par espace ou regex
2. *Gestion Base64url* :
   - Remplacement de caract√®res (=-= ‚Üí =+=, =_= ‚Üí =/=)
   - Calcul de rembourrage
   - Disponibilit√© du d√©codeur URL-safe (avantage JVM)
3. *Analyse JSON* : Native vs biblioth√®ques
4. *Gestion des erreurs* : Diff√©rences idiomatiques

** Analyse des performances inter-langages ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
| Langage    | Temps d'analyse (Œºs) | Utilisation m√©moire (KB) |
|------------+----------------------+--------------------------|
| Rust       |                  5.2 |                      1.8 |
| JavaScript |                 24.7 |                     12.3 |
| Python     |                 30.1 |                     15.7 |
| Clojure    |                 45.8 |                     28.4 |
| Shell      |                180.3 |                      8.9 |

*Remarque : Moyenne de 1000 ex√©cutions, mono-thread*

* Consid√©rations de s√©curit√©
** Bonnes pratiques de s√©curit√© JWT ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *Toujours v√©rifier les signatures avant d'analyser ou d'utiliser la charge utile*
- Utiliser des algorithmes solides (pr√©f√©rer RS256/ES256 √† HS256)
- Mettre en ≈ìuvre une gestion appropri√©e des cl√©s (rotation, stockage s√©curis√©)
- D√©finir des dur√©es de vie de jeton appropri√©es (jetons d'acc√®s de courte dur√©e)
- Inclure les revendications essentielles (iss, sub, exp, aud, iat)

** Attaques JWT courantes ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *Attaque "alg": "none"* - L'attaquant supprime l'exigence de validation de signature
- *Confusion d'algorithme* - Passage de l'asym√©trique (RS256) au sym√©trique (HS256)
- *Falsification de jeton* - Modification des revendications sans invalider la signature
- *Injection de jeton* - Utilisation d'un jeton d'un contexte dans un autre
- *Attaques par rejeu* - R√©utilisation de jetons captur√©s

** Gestion du cycle de vie des jetons ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *Mod√®les de jeton de rafra√Æchissement* - Obtention s√©curis√©e de nouveaux jetons d'acc√®s
- *R√©vocation de jeton* - Invalidation des jetons avant expiration
- *Pipeline de validation de jeton* - Ordre appropri√© des op√©rations
- *Liste noire* - Suivi des jetons compromis ou d√©connect√©s

#+BEGIN_SRC dot :file images/token-lifecycle.png :cmdline -Kdot -Tpng
digraph {
  node [shape=box, style=filled, fillcolor="#f5f5f5"];
  edge [fontname="Arial"];
  
  issue [label="√âmission du jeton", fillcolor="#e6ffe6"];
  validate [label="Validation du jeton", fillcolor="#e6f3ff"];
  refresh [label="Rafra√Æchissement du jeton", fillcolor="#fff0e6"];
  revoke [label="R√©vocation du jeton", fillcolor="#ffe6e6"];
  
  issue -> validate -> refresh -> validate;
  validate -> revoke;
}
#+END_SRC

* Applications r√©elles
** Comparaison d'impl√©mentation inter-langages
#+ATTR_BEAMER: :overlay <+->
| Fonctionnalit√© | JavaScript | Python | Rust | Clojure | TypeScript |
|---------------|------------|--------|------|---------|------------|
| S√ªret√© du type | Limit√©e | Optionnelle | Forte | Dynamique | Forte |
| Gestion Base64 | Manuelle | Int√©gr√©e | Crates | JVM | Manuelle |
| Gestion erreurs | try/catch | Exceptions | Result | Monadique | try/catch |
| Performance | Moyenne | Faible | √âlev√©e | Moyenne | Moyenne |
| Biblioth√®ques JWT | Nombreuses | Plusieurs | Peu | Peu | Nombreuses |

** JWT en production
#+ATTR_BEAMER: :overlay <+->
- Validation de jeton par passerelle API
- Autorisation de microservices
- Impl√©mentations d'authentification unique
- Authentification d'applications mobiles
- Communication serveur √† serveur

** Flux JWT
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC dot :file images/jwt-flow-detailed.png :cmdline -Kdot -Tpng
digraph {
  rankdir=LR;
  node [shape=box, style=rounded];
  subgraph cluster_validation {
    label="Processus de validation s√©curis√©";
    style=dashed;
    color=gray;
    "Extraire JWT" -> "V√©rifier signature" -> "Valider revendications" -> "V√©rifier r√©vocation";
  }
  
  Client -> "Service Auth" [label="1. Connexion"];
  "Service Auth" -> Client [label="2. JWT"];
  Client -> "Passerelle API" [label="3. Requ√™te + JWT"];
  "Passerelle API" -> "Extraire JWT";
  "V√©rifier r√©vocation" -> "Microservice" [label="4. Requ√™te autoris√©e"];
  "Microservice" -> Client [label="5. R√©ponse"];
}
#+END_SRC

* D√©bogage et d√©pannage
** Probl√®mes JWT courants et solutions
#+ATTR_BEAMER: :overlay <+->
- *Signature invalide* - V√©rifier la correspondance des cl√©s, la coh√©rence de l'algorithme
- *Jetons expir√©s* - V√©rifier la synchronisation d'horloge client/serveur
- *Jetons mal form√©s* - Inspecter l'encodage, assurer une gestion base64url appropri√©e
- *Revendications manquantes* - Valider la structure du jeton par rapport au sch√©ma attendu
- *Incompatibilit√© d'algorithme* - Confirmer que l'alg d'en-t√™te correspond √† l'impl√©mentation

** Outils de d√©bogage
#+ATTR_BEAMER: :overlay <+->
- D√©bogueur JWT en ligne (jwt.io)
- Biblioth√®ques JWT sp√©cifiques au langage avec options de d√©bogage
- Outils d'inspection Base64
- Inspection des requ√™tes/r√©ponses avec les outils de d√©veloppement

* Conclusion
** Aper√ßus inter-paradigmes
#+ATTR_BEAMER: :overlay <+->
| Paradigme | Forces | Application JWT |
|-----------|--------|----------------|
| Orient√© objet | Encapsulation, h√©ritage | Jeton avec m√©thodes de validation |
| Fonctionnel | Composition, immuabilit√© | Pipeline de transformation pour l'analyse |
| Proc√©dural | Simplicit√©, performance | Validateurs l√©gers |
| R√©actif | Gestion d'√©v√©nements | V√©rification de jeton dans les flux asynchrones |

** √Ä retenir
#+ATTR_BEAMER: :overlay <+->
1. L'encodage Base64url n√©cessite une attention particuli√®re
2. Chaque langage pr√©sente des avantages d'analyse idiomatiques
3. Les approches fonctionnelles excellent pour les pipelines de transformation
4. La s√©curit√© d'abord : toujours v√©rifier les signatures avant l'analyse
5. Consid√©rer le cycle de vie du jeton pour une impl√©mentation compl√®te
6. Les biblioth√®ques font gagner du temps mais comprendre les m√©canismes internes est important
7. Suivre les meilleures pratiques sp√©cifiques au langage

** Ressources d'apprentissage
#+ATTR_BEAMER: :overlay <+->
- JWT RFC 7519 : https://tools.ietf.org/html/rfc7519
- Meilleures pratiques de s√©curit√© JWT (IETF) : https://datatracker.ietf.org/doc/html/draft-ietf-oauth-jwt-bcp
- Fiche de triche OWASP JWT : https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html
- Guides de s√©curit√© sp√©cifiques aux langages : voir la documentation du d√©p√¥t

** Glossaire JWT pour d√©butants üî∞
#+ATTR_BEAMER: :overlay <+->
| Terme | D√©finition |
|-------|------------|
| JWT | JSON Web Token : un moyen compact et s√©curis√© pour les URL de repr√©senter des revendications √† transf√©rer entre parties |
| Revendications | Morceaux d'information affirm√©s √† propos d'un sujet (p. ex. ID utilisateur, heure d'expiration) |
| Base64url | Une variante de l'encodage Base64 s√ªre pour les URL qui peut √™tre incluse dans les URL sans √©chappement |
| En-t√™te | Premi√®re partie du JWT contenant des m√©tadonn√©es comme l'algorithme utilis√© pour la signature |
| Charge utile | Deuxi√®me partie du JWT contenant les donn√©es de revendication r√©elles |
| Signature | Troisi√®me partie du JWT qui v√©rifie que le jeton n'a pas √©t√© alt√©r√© |
| HMAC | Code d'authentification de message bas√© sur le hachage : technique pour assurer l'int√©grit√© des donn√©es √† l'aide d'une cl√© secr√®te |
| RSA | Cryptosyst√®me √† cl√© publique couramment utilis√© pour les signatures JWT |
| Sans √©tat | Authentification ne n√©cessitant pas de stockage de session c√¥t√© serveur |
| Jeton au porteur | Type de jeton d'acc√®s o√π la possession du jeton est suffisante pour l'authentification |

** Meilleures pratiques de s√©curit√© Python ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC python
import jwt
from cryptography.hazmat.primitives.constant_time import bytes_eq
from typing import Dict, Any, Optional, List, Union

# D√©finir un typage explicite pour les revendications JWT
class JWTClaims(TypedDict):
    iss: str  # √©metteur
    sub: str  # sujet
    exp: int  # temps d'expiration
    iat: int  # √©mis √† (ce temps)
    aud: Optional[Union[str, List[str]]]  # audience

def verify_and_decode_token(token: str, key: str, algorithms: List[str] = ['RS256']) -> JWTClaims:
    """V√©rifier et d√©coder un jeton JWT de mani√®re s√©curis√©e avec une gestion appropri√©e des erreurs.
    
    IMPORTANT : Cette fonction valide la signature AVANT de traiter la charge utile.
    """
    try:
        # Sp√©cifier explicitement les algorithmes autoris√©s (pr√©venir l'attaque d'algorithme 'none')
        # Valider la signature d'abord, puis d√©coder la charge utile
        payload = jwt.decode(
            token,
            key,
            algorithms=algorithms,  # Sp√©cifier explicitement les algorithmes autoris√©s
            options={"verify_signature": True}
        )
        return payload
    except jwt.ExpiredSignatureError:
        # Exception sp√©cifique pour un jeton expir√©
        raise ValueError("Le jeton a expir√©")
    except jwt.InvalidSignatureError:
        # Utiliser une erreur g√©n√©rique qui ne r√©v√®le pas les d√©tails de la signature
        raise ValueError("Authentification √©chou√©e")
    except jwt.DecodeError:
        # Erreur de d√©codage g√©n√©rique
        raise ValueError("Jeton invalide")
    except jwt.InvalidAlgorithmError:
        raise ValueError("Algorithme de jeton invalide")
    except Exception:
        # Attrape-tout avec message g√©n√©rique pour √©viter les fuites d'informations
        raise ValueError("Authentification √©chou√©e")
#+END_SRC

** Pipelines fonctionnels : Exemple Clojure am√©lior√© üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC clojure
;; Exploiter l'approche fonctionnelle de Clojure avec la macro thread-first
;; pour un pipeline de transformation plus propre

(defn decode-base64url
  "D√©coder une cha√Æne encod√©e en base64url en cha√Æne"
  [base64url-str]
  (-> base64url-str
      (java.util.Base64/getUrlDecoder)
      (.decode)
      (String.)))

(defn extract-token
  "Extraire le jeton de l'en-t√™te d'autorisation"
  [auth-header]
  (-> auth-header
      (clojure.string/split #" ")
      (second)))

(defn extract-header-part
  "Extraire la partie d'en-t√™te du jeton"
  [token]
  (-> token
      (clojure.string/split #"\.")
      (first)))

(defn parse-json
  "Analyser une cha√Æne JSON en map Clojure"
  [json-str]
  (json/read-str json-str :key-fn keyword))

;; IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
;; Cet exemple d√©montre la composition fonctionnelle pour la lisibilit√©
(defn decode-jwt-header
  "Extraire et d√©coder l'en-t√™te JWT en utilisant un pipeline fonctionnel"
  [auth-header]
  (-> auth-header
      (extract-token)
      (extract-header-part)
      (decode-base64url)
      (parse-json)))
#+END_SRC

** Questions ?
#+ATTR_BEAMER: :overlay <+->
Merci !

*Diapositives et exemples disponibles sur :* 
github.com/aidan-pace/jwt-parsing-examples

*Niveaux de difficult√© :* üî∞ D√©butant | üß© Interm√©diaire | ‚ö†Ô∏è Avanc√©