% Created 2025-05-03 Sat 14:50
% Intended LaTeX compiler: pdflatex
\documentclass[presentation,aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{inputenc}
\usepackage{fontenc}
\usepackage{babel}
\usetheme{metropolis}
\usecolortheme{default}
\author{Aidan Pace}
\date{\textit{{[}2025-04-28 Mon]}}
\title{An√°lisis de Cabeceras JWT a trav√©s de Paradigmas de Programaci√≥n}
\AtBeginSection[]{\begin{frame}<beamer>\frametitle{Agenda}\tableofcontents[currentsection]\end{frame}}
\hypersetup{
 pdfauthor={Aidan Pace},
 pdftitle={An√°lisis de Cabeceras JWT a trav√©s de Paradigmas de Programaci√≥n},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 31.0.50 (Org mode 9.7.11)}, 
 pdflang={Spanish}}
\begin{document}

\maketitle
\begin{frame}[label={sec:org59842cd}]{Introducci√≥n}
\begin{block}{An√°lisis de Cabeceras JWT a trav√©s de Paradigmas de Programaci√≥n}
\begin{itemize}[<+->]
\item Una exploraci√≥n entre lenguajes de t√©cnicas de an√°lisis de cabeceras JWT
\item PyCon US 2025, 14 de mayo - 22 de mayo, 2025
\item Aidan Pace (@aygp-dr)
\end{itemize}
\end{block}
\begin{block}{Lo que cubriremos}
\begin{itemize}[<+->]
\item Contexto hist√≥rico y evoluci√≥n de la autenticaci√≥n
\item Estructura JWT y fundamentos (üî∞ amigable para principiantes)
\item Desaf√≠os de la codificaci√≥n Base64url
\item Patrones de an√°lisis de cabeceras en diferentes lenguajes
\item Enfoques funcionales vs orientados a objetos
\item Modismos y mejores pr√°cticas espec√≠ficos de cada lenguaje
\item Consideraciones de seguridad y ataques comunes
\item An√°lisis de rendimiento y aplicaciones del mundo real
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org30143c7}]{Evoluci√≥n de la Autenticaci√≥n}
\begin{block}{Contexto Hist√≥rico de la Autenticaci√≥n}
\begin{itemize}[<+->]
\item Autenticaci√≥n temprana: Pares de nombre de usuario/contrase√±a
\item Sesiones del lado del servidor con cookies (con estado)
\item Surgimiento de la autenticaci√≥n basada en tokens (sin estado)
\item Estandarizaci√≥n JWT (RFC 7519, mayo 2015)
\item Flujos de autenticaci√≥n modernos (OAuth 2.0, OIDC)
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org86199bc},fragile]{Conceptos B√°sicos de JWT}
 \begin{block}{Repaso de la Estructura JWT üî∞}
\begin{verbatim}
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
\end{verbatim}

Tres segmentos codificados en base64url separados por puntos:
\begin{enumerate}
\item \alert{Cabecera} (algoritmo y tipo de token)
\item \alert{Carga √∫til} (reclamaciones/claims)
\item \alert{Firma}
\end{enumerate}

\begin{verbatim}
digraph {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor="#e6f3ff", fontname="monospace"];
  edge [fontname="Arial"];

  Header [label="Cabecera\n{\"alg\":\"HS256\",\n\"typ\":\"JWT\"}"];
  Payload [label="Carga √∫til\n{\"sub\":\"1234\",\n\"name\":\"User\",\n\"exp\":1516239022}"];
  Signature [label="Firma\nHMAC-SHA256(\n  base64UrlEncode(header) + '.' +\n  base64UrlEncode(payload),\n  secret\n)"];

  Header -> Payload [label="  .  "];
  Payload -> Signature [label="  .  "];
}
\end{verbatim}
\end{block}
\begin{block}{Reclamaciones JWT y Casos de Uso üî∞}
\alert{Reclamaciones Est√°ndar:}
\begin{itemize}
\item \texttt{iss} - Emisor (qui√©n cre√≥ el token)
\item \texttt{sub} - Sujeto (a qui√©n se refiere el token)
\item \texttt{aud} - Audiencia (qui√©n debe aceptar el token)
\item \texttt{exp} - Tiempo de expiraci√≥n
\item \texttt{nbf} - No antes de (este tiempo)
\item \texttt{iat} - Emitido en (este tiempo)
\item \texttt{jti} - ID JWT (identificador √∫nico)
\end{itemize}

\alert{Casos de Uso Comunes:}
\begin{itemize}
\item Autenticaci√≥n despu√©s del inicio de sesi√≥n
\item Autorizaci√≥n de API
\item Intercambio de informaci√≥n entre servicios
\item Inicio de Sesi√≥n √önico (SSO)
\end{itemize}
\end{block}
\begin{block}{El Desaf√≠o Base64url}
Base64 est√°ndar vs codificaci√≥n Base64url:
\begin{itemize}
\item La variante segura para URL reemplaza \texttt{+} con \texttt{-} y \texttt{/} con \texttt{\_}
\item El relleno (\texttt{=} ) a menudo se omite
\item Se utiliza para garantizar que los tokens puedan transmitirse de forma segura en las URL
\end{itemize}

\alert{¬°Cada lenguaje maneja esto de manera diferente!}
\end{block}
\end{frame}
\begin{frame}[label={sec:orga7e0c44},fragile]{Implementaciones en Lenguajes}
 \begin{block}{JavaScript (Navegador) üß©}
\begin{verbatim}
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
// Este ejemplo es solo para demostraci√≥n

// Decodificar la parte de la cabecera
const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(atob(headerPart));
console.log(decodedHeader);
\end{verbatim}

\alert{Nota}: \texttt{atob()} maneja base64 pero no espec√≠ficamente base64url
\end{block}
\begin{block}{Node.js üß©}
\begin{verbatim}
// Usando m√≥dulos incorporados
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
// Este ejemplo es solo para demostraci√≥n

const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(
  Buffer.from(headerPart, 'base64').toString()
);
console.log(decodedHeader);
\end{verbatim}
\end{block}
\begin{block}{TypeScript con Seguridad de Tipos üß©}
\begin{verbatim}
interface JwtHeader {
  alg: string;
  typ: string;
  kid?: string;  // Identificador de clave, opcional
}

function decodeJwtHeader(authHeader: string): JwtHeader {
  const token: string = authHeader.split(' ')[1];
  const headerPart: string = token.split('.')[0];

  // IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
  // Este ejemplo es solo para demostraci√≥n

  // Agregar relleno si es necesario
  const base64 = headerPart.replace(/-/g, '+').replace(/_/g, '/');
  const padded = base64.padEnd(base64.length + (4 - (base64.length % 4)) % 4, '=');

  const decodedHeader: JwtHeader = JSON.parse(
    Buffer.from(padded, 'base64').toString()
  );
  return decodedHeader;
}
\end{verbatim}
\end{block}
\begin{block}{Implementaci√≥n Python üß©}
\begin{verbatim}
import base64
import json
import typing

def decode_jwt_header(auth_header: str) -> typing.Dict[str, str]:
    """Decodifica la cabecera JWT del encabezado de autorizaci√≥n.

    IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
    Este ejemplo es solo para demostraci√≥n.
    """
    token = auth_header.split(' ')[1]
    header_part = token.split('.')[0]

    # Agregar relleno si es necesario
    padding_needed = len(header_part) % 4
    if padding_needed:
        header_part += '=' * (4 - padding_needed)

    # Decodificar base64
    decoded_bytes = base64.b64decode(header_part.replace('-', '+').replace('_', '/'))
    decoded_str = decoded_bytes.decode('utf-8')

    # Analizar JSON
    return json.loads(decoded_str)
\end{verbatim}
\end{block}
\begin{block}{Enfoques Funcionales: Clojure üß©}
\begin{verbatim}
;; IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
;; Este ejemplo es solo para demostraci√≥n.
(defn decode-jwt-header 
  "Decodifica la cabecera JWT del encabezado de autorizaci√≥n."
  [auth-header]
  (let [token (second (clojure.string/split auth-header #" "))
        header-part (first (clojure.string/split token #"\."))
        decoder (Base64/getUrlDecoder)
        decoded-bytes (.decode decoder header-part)
        decoded-str (String. decoded-bytes)
        header (json/read-str decoded-str)]
    header))
\end{verbatim}

\alert{Nota}: ¬°Base64 de la JVM tiene un decodificador URL incorporado!
\end{block}
\begin{block}{Enfoques Funcionales: Racket ‚ö†Ô∏è}
\begin{verbatim}
;; Convertir base64url a base64 est√°ndar y decodificar
(define (base64url->bytes str)
  (define padding (make-string (modulo (- 0 (string-length str)) 4) #\=))
  (define base64 (string-map (Œª (c)
                               (match c
                                 [#\- #\+]
                                 [#\_ #\/]
                                 [_ c]))
                             str))
  (base64-decode (string-append base64 padding)))

;; IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
;; Este ejemplo es solo para demostraci√≥n y usa composici√≥n funcional
(define (decode-jwt-header auth-header)
  ;; Tuber√≠a de transformaciones
  (define token (second (string-split auth-header)))
  (define header-part (first (string-split token ".")))
  (define decoded-bytes (base64url->bytes header-part))
  (define decoded-str (bytes->string/utf-8 decoded-bytes))
  (string->jsexpr decoded-str))
\end{verbatim}
\end{block}
\begin{block}{Implementaci√≥n de Bajo Nivel: Rust ‚ö†Ô∏è}
\begin{verbatim}
#[derive(Debug, Serialize, Deserialize)]
struct JwtHeader {
    alg: String,
    typ: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    kid: Option<String>,  // Identificador de clave opcional
}

/// Decodifica la cabecera JWT del encabezado de autorizaci√≥n
/// 
/// # IMPORTANTE
/// ¬°En producci√≥n, verifica la firma antes de analizar!
/// Este ejemplo es solo para demostraci√≥n.
/// 
/// # Manejo de Errores
/// Devuelve Result con la cabecera analizada o un error descriptivo
fn decode_jwt_header(auth_header: &str) -> Result<JwtHeader, Box<dyn std::error::Error>> {
    // Extraer token con manejo de errores
    let token = auth_header.split_whitespace().nth(1).ok_or("Encabezado de autenticaci√≥n inv√°lido")?;
    let header_part = token.split('.').next().ok_or("Formato de token inv√°lido")?;

    // Decodificar base64url a bytes (usando un decodificador seguro para URL adecuado)
    let decoded_bytes = general_purpose::URL_SAFE_NO_PAD.decode(header_part)?;

    // Analizar JSON con tipado fuerte
    let header: JwtHeader = serde_json::from_slice(&decoded_bytes)?;
    Ok(header)
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:org407a009},fragile]{An√°lisis}
 \begin{block}{Patrones Comunes y Variaciones üß©}
\begin{enumerate}[<+->]
\item \alert{Extracci√≥n de tokens}: Dividir por espacio o regex
\item \alert{Manejo de Base64url}:
\begin{itemize}
\item Reemplazo de caracteres (\texttt{-} ‚Üí \texttt{+}, \texttt{\_} ‚Üí \texttt{/})
\item C√°lculo de relleno
\item Disponibilidad de decodificador seguro para URL (ventaja JVM)
\end{itemize}
\item \alert{An√°lisis JSON}: Nativo vs bibliotecas
\item \alert{Manejo de errores}: Diferencias idiom√°ticas
\end{enumerate}
\end{block}
\begin{block}{An√°lisis de Rendimiento entre Lenguajes ‚ö†Ô∏è}
\begin{center}
\begin{tabular}{lrr}
Lenguaje & Tiempo de an√°lisis (Œºs) & Uso de memoria (KB)\\
\hline
Rust & 5.2 & 1.8\\
JavaScript & 24.7 & 12.3\\
Python & 30.1 & 15.7\\
Clojure & 45.8 & 28.4\\
Shell & 180.3 & 8.9\\
\end{tabular}
\end{center}

\alert{Nota: Promedio de 1000 ejecuciones, un solo hilo}
\end{block}
\end{frame}
\begin{frame}[label={sec:orga1ed9c1},fragile]{Consideraciones de Seguridad}
 \begin{block}{Mejores Pr√°cticas de Seguridad JWT ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{Siempre verificar firmas antes de analizar o usar la carga √∫til}
\item Usar algoritmos fuertes (preferir RS256/ES256 sobre HS256)
\item Implementar gesti√≥n de claves adecuada (rotaci√≥n, almacenamiento seguro)
\item Establecer tiempos de vida de token apropiados (tokens de acceso de corta duraci√≥n)
\item Incluir reclamaciones esenciales (iss, sub, exp, aud, iat)
\end{itemize}
\end{block}
\begin{block}{Ataques JWT Comunes ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{Ataque "alg": "none"} - El atacante elimina el requisito de validaci√≥n de firma
\item \alert{Confusi√≥n de algoritmo} - Cambiar de asim√©trico (RS256) a sim√©trico (HS256)
\item \alert{Manipulaci√≥n de tokens} - Modificar reclamaciones sin invalidar la firma
\item \alert{Inyecci√≥n de tokens} - Usar un token de un contexto en otro
\item \alert{Ataques de repetici√≥n} - Reutilizar tokens capturados
\end{itemize}
\end{block}
\begin{block}{Gesti√≥n del Ciclo de Vida de Tokens ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{Patrones de token de actualizaci√≥n} - Obtener nuevos tokens de acceso de forma segura
\item \alert{Revocaci√≥n de tokens} - Invalidar tokens antes de la expiraci√≥n
\item \alert{Tuber√≠a de validaci√≥n de tokens} - Orden adecuado de operaciones
\item \alert{Lista negra} - Seguimiento de tokens comprometidos o cerrados de sesi√≥n
\end{itemize}

\begin{verbatim}
digraph {
  node [shape=box, style=filled, fillcolor="#f5f5f5"];
  edge [fontname="Arial"];

  issue [label="Emisi√≥n de Token", fillcolor="#e6ffe6"];
  validate [label="Validaci√≥n de Token", fillcolor="#e6f3ff"];
  refresh [label="Actualizaci√≥n de Token", fillcolor="#fff0e6"];
  revoke [label="Revocaci√≥n de Token", fillcolor="#ffe6e6"];

  issue -> validate -> refresh -> validate;
  validate -> revoke;
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:org9619d75},fragile]{Aplicaciones del Mundo Real}
 \begin{block}{Comparaci√≥n de Implementaci√≥n entre Lenguajes}
\begin{center}
\begin{tabular}{llllll}
Caracter√≠stica & JavaScript & Python & Rust & Clojure & TypeScript\\
\hline
Seguridad de tipos & Limitada & Opcional & Fuerte & Din√°mica & Fuerte\\
Manejo de Base64 & Manual & Incorporado & Crates & JVM & Manual\\
Manejo de errores & try/catch & Excepciones & Result & Mon√°dico & try/catch\\
Rendimiento & Medio & Bajo & Alto & Medio & Medio\\
Bibliotecas JWT & Muchas & Varias & Pocas & Pocas & Muchas\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{JWT en Producci√≥n}
\begin{itemize}[<+->]
\item Validaci√≥n de tokens en API Gateway
\item Autorizaci√≥n de microservicios
\item Implementaciones de Inicio de Sesi√≥n √önico
\item Autenticaci√≥n de aplicaciones m√≥viles
\item Comunicaci√≥n servidor a servidor
\end{itemize}
\end{block}
\begin{block}{Flujo JWT}
\begin{verbatim}
digraph {
  rankdir=LR;
  node [shape=box, style=rounded];
  subgraph cluster_validation {
    label="Proceso de Validaci√≥n Segura";
    style=dashed;
    color=gray;
    "Extraer JWT" -> "Verificar Firma" -> "Validar Reclamaciones" -> "Verificar Revocaci√≥n";
  }

  Client -> "Servicio Auth" [label="1. Inicio de sesi√≥n"];
  "Servicio Auth" -> Client [label="2. JWT"];
  Client -> "API Gateway" [label="3. Solicitud + JWT"];
  "API Gateway" -> "Extraer JWT";
  "Verificar Revocaci√≥n" -> "Microservicio" [label="4. Solicitud Autorizada"];
  "Microservicio" -> Client [label="5. Respuesta"];
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:org026c79c}]{Depuraci√≥n y Soluci√≥n de Problemas}
\begin{block}{Problemas Comunes de JWT y Soluciones}
\begin{itemize}[<+->]
\item \alert{Firma inv√°lida} - Verificar coincidencia de claves, consistencia de algoritmo
\item \alert{Tokens expirados} - Verificar sincronizaci√≥n de reloj cliente/servidor
\item \alert{Tokens mal formados} - Inspeccionar codificaci√≥n, asegurar manejo adecuado de base64url
\item \alert{Reclamaciones faltantes} - Validar estructura del token contra esquema esperado
\item \alert{Desajuste de algoritmo} - Confirmar que el alg de cabecera coincide con la implementaci√≥n
\end{itemize}
\end{block}
\begin{block}{Herramientas de Depuraci√≥n}
\begin{itemize}[<+->]
\item Depurador JWT en l√≠nea (jwt.io)
\item Bibliotecas JWT espec√≠ficas de lenguaje con opciones de depuraci√≥n
\item Herramientas de inspecci√≥n Base64
\item Inspecci√≥n de solicitudes/respuestas con herramientas de desarrollador
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org8853002},fragile]{Conclusi√≥n}
 \begin{block}{Perspectivas entre Paradigmas}
\begin{center}
\begin{tabular}{lll}
Paradigma & Fortalezas & Aplicaci√≥n JWT\\
\hline
Orientado a objetos & Encapsulaci√≥n, herencia & Token con m√©todos de validaci√≥n\\
Funcional & Composici√≥n, inmutabilidad & Tuber√≠a de transformaci√≥n para an√°lisis\\
Procedural & Simplicidad, rendimiento & Validadores ligeros\\
Reactivo & Manejo de eventos & Verificaci√≥n de token en flujos as√≠ncronos\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{Conclusiones Principales}
\begin{enumerate}[<+->]
\item La codificaci√≥n Base64url requiere atenci√≥n especial
\item Cada lenguaje tiene ventajas idiom√°ticas de an√°lisis
\item Los enfoques funcionales brillan para tuber√≠as de transformaci√≥n
\item Seguridad primero: siempre verificar firmas antes de analizar
\item Considerar el ciclo de vida del token para una implementaci√≥n completa
\item Las bibliotecas ahorran tiempo pero entender los mecanismos internos es importante
\item Seguir las mejores pr√°cticas espec√≠ficas del lenguaje
\end{enumerate}
\end{block}
\begin{block}{Recursos de Aprendizaje}
\begin{itemize}[<+->]
\item JWT RFC 7519: \url{https://tools.ietf.org/html/rfc7519}
\item Mejores Pr√°cticas de Seguridad JWT (IETF): \url{https://datatracker.ietf.org/doc/html/draft-ietf-oauth-jwt-bcp}
\item Hoja de trucos OWASP JWT: \url{https://cheatsheetseries.owasp.org/cheatsheets/JSON\_Web\_Token\_for\_Java\_Cheat\_Sheet.html}
\item Gu√≠as de seguridad espec√≠ficas de lenguaje: ver documentaci√≥n del repositorio
\end{itemize}
\end{block}
\begin{block}{Glosario JWT para Principiantes üî∞}
\begin{center}
\begin{tabular}{ll}
T√©rmino & Definici√≥n\\
\hline
JWT & JSON Web Token: un medio compacto y seguro para URL de representar reclamaciones para transferir entre partes\\
Reclamaciones & Piezas de informaci√≥n afirmadas sobre un sujeto (p. ej., ID de usuario, tiempo de expiraci√≥n)\\
Base64url & Una variante de la codificaci√≥n Base64 segura para URL que puede incluirse en URLs sin escape\\
Cabecera & Primera parte del JWT que contiene metadatos como el algoritmo utilizado para firmar\\
Carga √∫til & Segunda parte del JWT que contiene los datos de reclamaciones reales\\
Firma & Tercera parte del JWT que verifica que el token no ha sido alterado\\
HMAC & C√≥digo de Autenticaci√≥n de Mensajes basado en Hash: t√©cnica para garantizar la integridad de datos usando una clave secreta\\
RSA & Criptosistema de clave p√∫blica com√∫nmente usado para firmas JWT\\
Sin estado & Autenticaci√≥n que no requiere almacenamiento de sesi√≥n del lado del servidor\\
Token al portador & Tipo de token de acceso donde la posesi√≥n del token es suficiente para la autenticaci√≥n\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{Mejores Pr√°cticas de Seguridad Python ‚ö†Ô∏è}
\begin{verbatim}
import jwt
from cryptography.hazmat.primitives.constant_time import bytes_eq
from typing import Dict, Any, Optional, List, Union

# Definir tipado expl√≠cito para reclamaciones JWT
class JWTClaims(TypedDict):
    iss: str  # emisor
    sub: str  # sujeto
    exp: int  # tiempo de expiraci√≥n
    iat: int  # emitido en
    aud: Optional[Union[str, List[str]]]  # audiencia

def verify_and_decode_token(token: str, key: str, algorithms: List[str] = ['RS256']) -> JWTClaims:
    """Verificar y decodificar un token JWT de forma segura con manejo de errores adecuado.

    IMPORTANTE: Esta funci√≥n valida la firma ANTES de procesar la carga √∫til.
    """
    try:
        # Especificar expl√≠citamente los algoritmos permitidos (prevenir ataque de algoritmo 'none')
        # Validar firma primero, luego decodificar carga √∫til
        payload = jwt.decode(
            token,
            key,
            algorithms=algorithms,  # Especificar expl√≠citamente algoritmos permitidos
            options={"verify_signature": True}
        )
        return payload
    except jwt.ExpiredSignatureError:
        # Excepci√≥n espec√≠fica para token expirado
        raise ValueError("El token ha expirado")
    except jwt.InvalidSignatureError:
        # Usar error gen√©rico que no revela detalles de firma
        raise ValueError("Autenticaci√≥n fallida")
    except jwt.DecodeError:
        # Error de decodificaci√≥n gen√©rico
        raise ValueError("Token inv√°lido")
    except jwt.InvalidAlgorithmError:
        raise ValueError("Algoritmo de token inv√°lido")
    except Exception:
        # Captura todo con mensaje gen√©rico para evitar fugas de informaci√≥n
        raise ValueError("Autenticaci√≥n fallida")
\end{verbatim}
\end{block}
\begin{block}{Tuber√≠as Funcionales: Ejemplo Clojure Mejorado üß©}
\begin{verbatim}
;; Aprovechando el enfoque funcional de Clojure con macro thread-first
;; para una tuber√≠a de transformaci√≥n m√°s limpia

(defn decode-base64url
  "Decodificar cadena codificada en base64url a cadena"
  [base64url-str]
  (-> base64url-str
      (java.util.Base64/getUrlDecoder)
      (.decode)
      (String.)))

(defn extract-token
  "Extraer token del encabezado de autorizaci√≥n"
  [auth-header]
  (-> auth-header
      (clojure.string/split #" ")
      (second)))

(defn extract-header-part
  "Extraer parte de cabecera del token"
  [token]
  (-> token
      (clojure.string/split #"\.")
      (first)))

(defn parse-json
  "Analizar cadena JSON a mapa Clojure"
  [json-str]
  (json/read-str json-str :key-fn keyword))

;; IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
;; Este ejemplo demuestra la composici√≥n funcional para legibilidad
(defn decode-jwt-header
  "Extraer y decodificar cabecera JWT usando una tuber√≠a funcional"
  [auth-header]
  (-> auth-header
      (extract-token)
      (extract-header-part)
      (decode-base64url)
      (parse-json)))
\end{verbatim}
\end{block}
\begin{block}{¬øPreguntas?}
¬°Gracias!

\alert{Diapositivas y ejemplos disponibles en:} 
github.com/aidan-pace/jwt-parsing-examples

\alert{Niveles de dificultad:} üî∞ Principiante | üß© Intermedio | ‚ö†Ô∏è Avanzado
\end{block}
\end{frame}
\end{document}
