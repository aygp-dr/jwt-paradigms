% Created 2025-05-03 Sat 14:49
% Intended LaTeX compiler: pdflatex
\documentclass[presentation,aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{inputenc}
\usepackage{fontenc}
\usepackage{babel}
\usetheme{metropolis}
\usecolortheme{default}
\author{Aidan Pace}
\date{\textit{{[}2025-04-28 Mon]}}
\title{Analyse des en-t√™tes JWT √† travers les paradigmes de programmation}
\AtBeginSection[]{\begin{frame}<beamer>\frametitle{Agenda}\tableofcontents[currentsection]\end{frame}}
\hypersetup{
 pdfauthor={Aidan Pace},
 pdftitle={Analyse des en-t√™tes JWT √† travers les paradigmes de programmation},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 31.0.50 (Org mode 9.7.11)}, 
 pdflang={French}}
\begin{document}

\maketitle
\begin{frame}[label={sec:org367be5f}]{Introduction}
\begin{block}{Analyse des en-t√™tes JWT √† travers les paradigmes de programmation}
\begin{itemize}[<+->]
\item Une exploration inter-langages des techniques d'analyse des en-t√™tes JWT
\item PyCon US 2025, 14 mai - 22 mai 2025
\item Aidan Pace (@aygp-dr)
\end{itemize}
\end{block}
\begin{block}{Ce que nous allons couvrir}
\begin{itemize}[<+->]
\item Contexte historique et √©volution de l'authentification
\item Structure JWT et fondamentaux (üî∞ adapt√© aux d√©butants)
\item D√©fis de l'encodage Base64url
\item Mod√®les d'analyse d'en-t√™tes dans diff√©rents langages
\item Approches fonctionnelles vs. orient√©es objet
\item Idiomes et bonnes pratiques sp√©cifiques aux langages
\item Consid√©rations de s√©curit√© et attaques courantes
\item Analyse des performances et applications r√©elles
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:org70c48b0}]{√âvolution de l'authentification}
\begin{block}{Contexte historique de l'authentification}
\begin{itemize}[<+->]
\item Authentification primitive : Paires nom d'utilisateur/mot de passe
\item Sessions c√¥t√© serveur avec cookies (avec √©tat)
\item √âmergence de l'authentification par jetons (sans √©tat)
\item Standardisation JWT (RFC 7519, mai 2015)
\item Flux d'authentification modernes (OAuth 2.0, OIDC)
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgf0db282},fragile]{Bases de JWT}
 \begin{block}{Rappel de la structure JWT üî∞}
\begin{verbatim}
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
\end{verbatim}

Trois segments encod√©s en base64url s√©par√©s par des points :
\begin{enumerate}
\item \alert{En-t√™te} (algorithme et type de jeton)
\item \alert{Charge utile} (revendications/claims)
\item \alert{Signature}
\end{enumerate}

\begin{verbatim}
digraph {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor="#e6f3ff", fontname="monospace"];
  edge [fontname="Arial"];

  Header [label="En-t√™te\n{\"alg\":\"HS256\",\n\"typ\":\"JWT\"}"];
  Payload [label="Charge utile\n{\"sub\":\"1234\",\n\"name\":\"User\",\n\"exp\":1516239022}"];
  Signature [label="Signature\nHMAC-SHA256(\n  base64UrlEncode(header) + '.' +\n  base64UrlEncode(payload),\n  secret\n)"];

  Header -> Payload [label="  .  "];
  Payload -> Signature [label="  .  "];
}
\end{verbatim}
\end{block}
\begin{block}{Revendications JWT et cas d'utilisation üî∞}
\alert{Revendications standard :}
\begin{itemize}
\item \texttt{iss} - √âmetteur (qui a cr√©√© le jeton)
\item \texttt{sub} - Sujet (√† qui le jeton fait r√©f√©rence)
\item \texttt{aud} - Audience (qui devrait accepter le jeton)
\item \texttt{exp} - Temps d'expiration
\item \texttt{nbf} - Pas avant (ce temps)
\item \texttt{iat} - √âmis √† (ce temps)
\item \texttt{jti} - ID JWT (identifiant unique)
\end{itemize}

\alert{Cas d'utilisation courants :}
\begin{itemize}
\item Authentification apr√®s connexion
\item Autorisation d'API
\item √âchange d'informations entre services
\item Authentification unique (SSO)
\end{itemize}
\end{block}
\begin{block}{Le d√©fi Base64url}
Base64 standard vs encodage Base64url :
\begin{itemize}
\item La variante URL-safe remplace \texttt{+} par \texttt{-} et \texttt{/} par \texttt{\_}
\item Le rembourrage (\texttt{=} ) est souvent omis
\item Utilis√© pour garantir que les jetons peuvent √™tre transmis en toute s√©curit√© dans les URL
\end{itemize}

\alert{Chaque langage g√®re cela diff√©remment !}
\end{block}
\end{frame}
\begin{frame}[label={sec:org25093b4},fragile]{Impl√©mentations dans diff√©rents langages}
 \begin{block}{JavaScript (Navigateur) üß©}
\begin{verbatim}
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
// Cet exemple est uniquement √† des fins de d√©monstration

// D√©codage de la partie en-t√™te
const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(atob(headerPart));
console.log(decodedHeader);
\end{verbatim}

\alert{Remarque} : \texttt{atob()} g√®re base64 mais pas sp√©cifiquement base64url
\end{block}
\begin{block}{Node.js üß©}
\begin{verbatim}
// Utilisation des modules int√©gr√©s
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
// Cet exemple est uniquement √† des fins de d√©monstration

const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(
  Buffer.from(headerPart, 'base64').toString()
);
console.log(decodedHeader);
\end{verbatim}
\end{block}
\begin{block}{TypeScript avec s√ªret√© du typage üß©}
\begin{verbatim}
interface JwtHeader {
  alg: string;
  typ: string;
  kid?: string;  // Identifiant de cl√©, optionnel
}

function decodeJwtHeader(authHeader: string): JwtHeader {
  const token: string = authHeader.split(' ')[1];
  const headerPart: string = token.split('.')[0];

  // IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
  // Cet exemple est uniquement √† des fins de d√©monstration

  // Ajout de rembourrage si n√©cessaire
  const base64 = headerPart.replace(/-/g, '+').replace(/_/g, '/');
  const padded = base64.padEnd(base64.length + (4 - (base64.length % 4)) % 4, '=');

  const decodedHeader: JwtHeader = JSON.parse(
    Buffer.from(padded, 'base64').toString()
  );
  return decodedHeader;
}
\end{verbatim}
\end{block}
\begin{block}{Impl√©mentation Python üß©}
\begin{verbatim}
import base64
import json
import typing

def decode_jwt_header(auth_header: str) -> typing.Dict[str, str]:
    """D√©code l'en-t√™te JWT √† partir de l'en-t√™te d'autorisation.

    IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
    Cet exemple est uniquement √† des fins de d√©monstration.
    """
    token = auth_header.split(' ')[1]
    header_part = token.split('.')[0]

    # Ajout de rembourrage si n√©cessaire
    padding_needed = len(header_part) % 4
    if padding_needed:
        header_part += '=' * (4 - padding_needed)

    # D√©codage base64
    decoded_bytes = base64.b64decode(header_part.replace('-', '+').replace('_', '/'))
    decoded_str = decoded_bytes.decode('utf-8')

    # Analyse JSON
    return json.loads(decoded_str)
\end{verbatim}
\end{block}
\begin{block}{Approches fonctionnelles : Clojure üß©}
\begin{verbatim}
;; IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
;; Cet exemple est uniquement √† des fins de d√©monstration.
(defn decode-jwt-header 
  "D√©code l'en-t√™te JWT √† partir de l'en-t√™te d'autorisation."
  [auth-header]
  (let [token (second (clojure.string/split auth-header #" "))
        header-part (first (clojure.string/split token #"\."))
        decoder (Base64/getUrlDecoder)
        decoded-bytes (.decode decoder header-part)
        decoded-str (String. decoded-bytes)
        header (json/read-str decoded-str)]
    header))
\end{verbatim}

\alert{Remarque} : Base64 de la JVM poss√®de un d√©codeur URL int√©gr√© !
\end{block}
\begin{block}{Approches fonctionnelles : Racket ‚ö†Ô∏è}
\begin{verbatim}
;; Convertir base64url en base64 standard et d√©coder
(define (base64url->bytes str)
  (define padding (make-string (modulo (- 0 (string-length str)) 4) #\=))
  (define base64 (string-map (Œª (c)
                               (match c
                                 [#\- #\+]
                                 [#\_ #\/]
                                 [_ c]))
                             str))
  (base64-decode (string-append base64 padding)))

;; IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
;; Cet exemple est uniquement √† des fins de d√©monstration et utilise la composition fonctionnelle
(define (decode-jwt-header auth-header)
  ;; Pipeline de transformations
  (define token (second (string-split auth-header)))
  (define header-part (first (string-split token ".")))
  (define decoded-bytes (base64url->bytes header-part))
  (define decoded-str (bytes->string/utf-8 decoded-bytes))
  (string->jsexpr decoded-str))
\end{verbatim}
\end{block}
\begin{block}{Impl√©mentation de bas niveau : Rust ‚ö†Ô∏è}
\begin{verbatim}
#[derive(Debug, Serialize, Deserialize)]
struct JwtHeader {
    alg: String,
    typ: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    kid: Option<String>,  // Identifiant de cl√© optionnel
}

/// D√©code l'en-t√™te JWT √† partir de l'en-t√™te d'autorisation
/// 
/// # IMPORTANT
/// En production, v√©rifiez la signature avant l'analyse !
/// Cet exemple est uniquement √† des fins de d√©monstration.
/// 
/// # Gestion des erreurs
/// Renvoie Result avec soit l'en-t√™te analys√©, soit une erreur descriptive
fn decode_jwt_header(auth_header: &str) -> Result<JwtHeader, Box<dyn std::error::Error>> {
    // Extraction du jeton avec gestion des erreurs
    let token = auth_header.split_whitespace().nth(1).ok_or("En-t√™te d'auth invalide")?;
    let header_part = token.split('.').next().ok_or("Format de jeton invalide")?;

    // D√©codage base64url en octets (avec d√©codeur URL s√©curis√© appropri√©)
    let decoded_bytes = general_purpose::URL_SAFE_NO_PAD.decode(header_part)?;

    // Analyse JSON avec typage fort
    let header: JwtHeader = serde_json::from_slice(&decoded_bytes)?;
    Ok(header)
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:org68edeb1},fragile]{Analyse}
 \begin{block}{Mod√®les communs et variations üß©}
\begin{enumerate}[<+->]
\item \alert{Extraction de jeton} : Division par espace ou regex
\item \alert{Gestion Base64url} :
\begin{itemize}
\item Remplacement de caract√®res (\texttt{-} ‚Üí \texttt{+}, \texttt{\_} ‚Üí \texttt{/})
\item Calcul de rembourrage
\item Disponibilit√© du d√©codeur URL-safe (avantage JVM)
\end{itemize}
\item \alert{Analyse JSON} : Native vs biblioth√®ques
\item \alert{Gestion des erreurs} : Diff√©rences idiomatiques
\end{enumerate}
\end{block}
\begin{block}{Analyse des performances inter-langages ‚ö†Ô∏è}
\begin{center}
\begin{tabular}{lrr}
Langage & Temps d'analyse (Œºs) & Utilisation m√©moire (KB)\\
\hline
Rust & 5.2 & 1.8\\
JavaScript & 24.7 & 12.3\\
Python & 30.1 & 15.7\\
Clojure & 45.8 & 28.4\\
Shell & 180.3 & 8.9\\
\end{tabular}
\end{center}

\alert{Remarque : Moyenne de 1000 ex√©cutions, mono-thread}
\end{block}
\end{frame}
\begin{frame}[label={sec:org24b20a0},fragile]{Consid√©rations de s√©curit√©}
 \begin{block}{Bonnes pratiques de s√©curit√© JWT ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{Toujours v√©rifier les signatures avant d'analyser ou d'utiliser la charge utile}
\item Utiliser des algorithmes solides (pr√©f√©rer RS256/ES256 √† HS256)
\item Mettre en ≈ìuvre une gestion appropri√©e des cl√©s (rotation, stockage s√©curis√©)
\item D√©finir des dur√©es de vie de jeton appropri√©es (jetons d'acc√®s de courte dur√©e)
\item Inclure les revendications essentielles (iss, sub, exp, aud, iat)
\end{itemize}
\end{block}
\begin{block}{Attaques JWT courantes ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{Attaque "alg": "none"} - L'attaquant supprime l'exigence de validation de signature
\item \alert{Confusion d'algorithme} - Passage de l'asym√©trique (RS256) au sym√©trique (HS256)
\item \alert{Falsification de jeton} - Modification des revendications sans invalider la signature
\item \alert{Injection de jeton} - Utilisation d'un jeton d'un contexte dans un autre
\item \alert{Attaques par rejeu} - R√©utilisation de jetons captur√©s
\end{itemize}
\end{block}
\begin{block}{Gestion du cycle de vie des jetons ‚ö†Ô∏è}
\begin{itemize}[<+->]
\item \alert{Mod√®les de jeton de rafra√Æchissement} - Obtention s√©curis√©e de nouveaux jetons d'acc√®s
\item \alert{R√©vocation de jeton} - Invalidation des jetons avant expiration
\item \alert{Pipeline de validation de jeton} - Ordre appropri√© des op√©rations
\item \alert{Liste noire} - Suivi des jetons compromis ou d√©connect√©s
\end{itemize}

\begin{verbatim}
digraph {
  node [shape=box, style=filled, fillcolor="#f5f5f5"];
  edge [fontname="Arial"];

  issue [label="√âmission du jeton", fillcolor="#e6ffe6"];
  validate [label="Validation du jeton", fillcolor="#e6f3ff"];
  refresh [label="Rafra√Æchissement du jeton", fillcolor="#fff0e6"];
  revoke [label="R√©vocation du jeton", fillcolor="#ffe6e6"];

  issue -> validate -> refresh -> validate;
  validate -> revoke;
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:org9bdba1c},fragile]{Applications r√©elles}
 \begin{block}{Comparaison d'impl√©mentation inter-langages}
\begin{center}
\begin{tabular}{llllll}
Fonctionnalit√© & JavaScript & Python & Rust & Clojure & TypeScript\\
\hline
S√ªret√© du type & Limit√©e & Optionnelle & Forte & Dynamique & Forte\\
Gestion Base64 & Manuelle & Int√©gr√©e & Crates & JVM & Manuelle\\
Gestion erreurs & try/catch & Exceptions & Result & Monadique & try/catch\\
Performance & Moyenne & Faible & √âlev√©e & Moyenne & Moyenne\\
Biblioth√®ques JWT & Nombreuses & Plusieurs & Peu & Peu & Nombreuses\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{JWT en production}
\begin{itemize}[<+->]
\item Validation de jeton par passerelle API
\item Autorisation de microservices
\item Impl√©mentations d'authentification unique
\item Authentification d'applications mobiles
\item Communication serveur √† serveur
\end{itemize}
\end{block}
\begin{block}{Flux JWT}
\begin{verbatim}
digraph {
  rankdir=LR;
  node [shape=box, style=rounded];
  subgraph cluster_validation {
    label="Processus de validation s√©curis√©";
    style=dashed;
    color=gray;
    "Extraire JWT" -> "V√©rifier signature" -> "Valider revendications" -> "V√©rifier r√©vocation";
  }

  Client -> "Service Auth" [label="1. Connexion"];
  "Service Auth" -> Client [label="2. JWT"];
  Client -> "Passerelle API" [label="3. Requ√™te + JWT"];
  "Passerelle API" -> "Extraire JWT";
  "V√©rifier r√©vocation" -> "Microservice" [label="4. Requ√™te autoris√©e"];
  "Microservice" -> Client [label="5. R√©ponse"];
}
\end{verbatim}
\end{block}
\end{frame}
\begin{frame}[label={sec:org0af7ffd}]{D√©bogage et d√©pannage}
\begin{block}{Probl√®mes JWT courants et solutions}
\begin{itemize}[<+->]
\item \alert{Signature invalide} - V√©rifier la correspondance des cl√©s, la coh√©rence de l'algorithme
\item \alert{Jetons expir√©s} - V√©rifier la synchronisation d'horloge client/serveur
\item \alert{Jetons mal form√©s} - Inspecter l'encodage, assurer une gestion base64url appropri√©e
\item \alert{Revendications manquantes} - Valider la structure du jeton par rapport au sch√©ma attendu
\item \alert{Incompatibilit√© d'algorithme} - Confirmer que l'alg d'en-t√™te correspond √† l'impl√©mentation
\end{itemize}
\end{block}
\begin{block}{Outils de d√©bogage}
\begin{itemize}[<+->]
\item D√©bogueur JWT en ligne (jwt.io)
\item Biblioth√®ques JWT sp√©cifiques au langage avec options de d√©bogage
\item Outils d'inspection Base64
\item Inspection des requ√™tes/r√©ponses avec les outils de d√©veloppement
\end{itemize}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgc6c3753},fragile]{Conclusion}
 \begin{block}{Aper√ßus inter-paradigmes}
\begin{center}
\begin{tabular}{lll}
Paradigme & Forces & Application JWT\\
\hline
Orient√© objet & Encapsulation, h√©ritage & Jeton avec m√©thodes de validation\\
Fonctionnel & Composition, immuabilit√© & Pipeline de transformation pour l'analyse\\
Proc√©dural & Simplicit√©, performance & Validateurs l√©gers\\
R√©actif & Gestion d'√©v√©nements & V√©rification de jeton dans les flux asynchrones\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{√Ä retenir}
\begin{enumerate}[<+->]
\item L'encodage Base64url n√©cessite une attention particuli√®re
\item Chaque langage pr√©sente des avantages d'analyse idiomatiques
\item Les approches fonctionnelles excellent pour les pipelines de transformation
\item La s√©curit√© d'abord : toujours v√©rifier les signatures avant l'analyse
\item Consid√©rer le cycle de vie du jeton pour une impl√©mentation compl√®te
\item Les biblioth√®ques font gagner du temps mais comprendre les m√©canismes internes est important
\item Suivre les meilleures pratiques sp√©cifiques au langage
\end{enumerate}
\end{block}
\begin{block}{Ressources d'apprentissage}
\begin{itemize}[<+->]
\item JWT RFC 7519 : \url{https://tools.ietf.org/html/rfc7519}
\item Meilleures pratiques de s√©curit√© JWT (IETF) : \url{https://datatracker.ietf.org/doc/html/draft-ietf-oauth-jwt-bcp}
\item Fiche de triche OWASP JWT : \url{https://cheatsheetseries.owasp.org/cheatsheets/JSON\_Web\_Token\_for\_Java\_Cheat\_Sheet.html}
\item Guides de s√©curit√© sp√©cifiques aux langages : voir la documentation du d√©p√¥t
\end{itemize}
\end{block}
\begin{block}{Glossaire JWT pour d√©butants üî∞}
\begin{center}
\begin{tabular}{ll}
Terme & D√©finition\\
\hline
JWT & JSON Web Token : un moyen compact et s√©curis√© pour les URL de repr√©senter des revendications √† transf√©rer entre parties\\
Revendications & Morceaux d'information affirm√©s √† propos d'un sujet (p. ex. ID utilisateur, heure d'expiration)\\
Base64url & Une variante de l'encodage Base64 s√ªre pour les URL qui peut √™tre incluse dans les URL sans √©chappement\\
En-t√™te & Premi√®re partie du JWT contenant des m√©tadonn√©es comme l'algorithme utilis√© pour la signature\\
Charge utile & Deuxi√®me partie du JWT contenant les donn√©es de revendication r√©elles\\
Signature & Troisi√®me partie du JWT qui v√©rifie que le jeton n'a pas √©t√© alt√©r√©\\
HMAC & Code d'authentification de message bas√© sur le hachage : technique pour assurer l'int√©grit√© des donn√©es √† l'aide d'une cl√© secr√®te\\
RSA & Cryptosyst√®me √† cl√© publique couramment utilis√© pour les signatures JWT\\
Sans √©tat & Authentification ne n√©cessitant pas de stockage de session c√¥t√© serveur\\
Jeton au porteur & Type de jeton d'acc√®s o√π la possession du jeton est suffisante pour l'authentification\\
\end{tabular}
\end{center}
\end{block}
\begin{block}{Meilleures pratiques de s√©curit√© Python ‚ö†Ô∏è}
\begin{verbatim}
import jwt
from cryptography.hazmat.primitives.constant_time import bytes_eq
from typing import Dict, Any, Optional, List, Union

# D√©finir un typage explicite pour les revendications JWT
class JWTClaims(TypedDict):
    iss: str  # √©metteur
    sub: str  # sujet
    exp: int  # temps d'expiration
    iat: int  # √©mis √† (ce temps)
    aud: Optional[Union[str, List[str]]]  # audience

def verify_and_decode_token(token: str, key: str, algorithms: List[str] = ['RS256']) -> JWTClaims:
    """V√©rifier et d√©coder un jeton JWT de mani√®re s√©curis√©e avec une gestion appropri√©e des erreurs.

    IMPORTANT : Cette fonction valide la signature AVANT de traiter la charge utile.
    """
    try:
        # Sp√©cifier explicitement les algorithmes autoris√©s (pr√©venir l'attaque d'algorithme 'none')
        # Valider la signature d'abord, puis d√©coder la charge utile
        payload = jwt.decode(
            token,
            key,
            algorithms=algorithms,  # Sp√©cifier explicitement les algorithmes autoris√©s
            options={"verify_signature": True}
        )
        return payload
    except jwt.ExpiredSignatureError:
        # Exception sp√©cifique pour un jeton expir√©
        raise ValueError("Le jeton a expir√©")
    except jwt.InvalidSignatureError:
        # Utiliser une erreur g√©n√©rique qui ne r√©v√®le pas les d√©tails de la signature
        raise ValueError("Authentification √©chou√©e")
    except jwt.DecodeError:
        # Erreur de d√©codage g√©n√©rique
        raise ValueError("Jeton invalide")
    except jwt.InvalidAlgorithmError:
        raise ValueError("Algorithme de jeton invalide")
    except Exception:
        # Attrape-tout avec message g√©n√©rique pour √©viter les fuites d'informations
        raise ValueError("Authentification √©chou√©e")
\end{verbatim}
\end{block}
\begin{block}{Pipelines fonctionnels : Exemple Clojure am√©lior√© üß©}
\begin{verbatim}
;; Exploiter l'approche fonctionnelle de Clojure avec la macro thread-first
;; pour un pipeline de transformation plus propre

(defn decode-base64url
  "D√©coder une cha√Æne encod√©e en base64url en cha√Æne"
  [base64url-str]
  (-> base64url-str
      (java.util.Base64/getUrlDecoder)
      (.decode)
      (String.)))

(defn extract-token
  "Extraire le jeton de l'en-t√™te d'autorisation"
  [auth-header]
  (-> auth-header
      (clojure.string/split #" ")
      (second)))

(defn extract-header-part
  "Extraire la partie d'en-t√™te du jeton"
  [token]
  (-> token
      (clojure.string/split #"\.")
      (first)))

(defn parse-json
  "Analyser une cha√Æne JSON en map Clojure"
  [json-str]
  (json/read-str json-str :key-fn keyword))

;; IMPORTANT : En production, v√©rifiez la signature avant l'analyse !
;; Cet exemple d√©montre la composition fonctionnelle pour la lisibilit√©
(defn decode-jwt-header
  "Extraire et d√©coder l'en-t√™te JWT en utilisant un pipeline fonctionnel"
  [auth-header]
  (-> auth-header
      (extract-token)
      (extract-header-part)
      (decode-base64url)
      (parse-json)))
\end{verbatim}
\end{block}
\begin{block}{Questions ?}
Merci !

\alert{Diapositives et exemples disponibles sur :} 
github.com/aidan-pace/jwt-parsing-examples

\alert{Niveaux de difficult√© :} üî∞ D√©butant | üß© Interm√©diaire | ‚ö†Ô∏è Avanc√©
\end{block}
\end{frame}
\end{document}
