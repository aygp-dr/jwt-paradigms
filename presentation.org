#+TITLE: Parsing JWT Headers Across Programming Paradigms
#+AUTHOR: Aidan Pace
#+EMAIL: apace@defrecord.com
#+DATE: [2025-04-28]
#+LANGUAGE: en
#+OPTIONS: toc:nil num:nil ^:nil
#+STARTUP: beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation,aspectratio=169]
#+BEAMER_THEME: metropolis
#+BEAMER_COLOR_THEME: default
#+BEAMER_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Agenda}\tableofcontents[currentsection]\end{frame}}

* Introduction
** Parsing JWT Headers Across Programming Paradigms
#+ATTR_BEAMER: :overlay <+->
- A cross-language exploration of JWT header parsing techniques
- SPLASH/StrangeLoop/PyConf/RacketCon/EuroLISP 2025
- Aidan Pace (@aygp-dr)

** What We'll Cover
#+ATTR_BEAMER: :overlay <+->
- Historical context and authentication evolution
- JWT structure and fundamentals (üî∞ beginner-friendly)
- Base64url encoding challenges
- Header parsing patterns across languages
- Functional vs object-oriented approaches
- Language-specific idioms and best practices
- Security considerations and common attacks
- Performance analysis and real-world applications

* Authentication Evolution
** Historical Context of Authentication
#+ATTR_BEAMER: :overlay <+->
- Early authentication: Username/password pairs
- Server-side sessions with cookies (stateful)
- Token-based authentication emergence (stateless)
- JWT standardization (RFC 7519, May 2015)
- Modern authentication flows (OAuth 2.0, OIDC)

* JWT Basics
** JWT Structure Refresher üî∞
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
#+END_SRC

Three dot-separated base64url-encoded segments:
1. *Header* (algorithm & token type)
2. *Payload* (claims)
3. *Signature*

#+BEGIN_SRC dot :file images/jwt-structure.png :cmdline -Kdot -Tpng
digraph {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor="#e6f3ff", fontname="monospace"];
  edge [fontname="Arial"];
  
  Header [label="Header\n{\"alg\":\"HS256\",\n\"typ\":\"JWT\"}"];
  Payload [label="Payload\n{\"sub\":\"1234\",\n\"name\":\"User\",\n\"exp\":1516239022}"];
  Signature [label="Signature\nHMAC-SHA256(\n  base64UrlEncode(header) + '.' +\n  base64UrlEncode(payload),\n  secret\n)"];
  
  Header -> Payload [label="  .  "];
  Payload -> Signature [label="  .  "];
}
#+END_SRC

** JWT Claims & Use Cases üî∞
#+ATTR_BEAMER: :overlay <+->
*Standard Claims:*
- =iss= - Issuer (who created the token)
- =sub= - Subject (whom the token refers to)
- =aud= - Audience (who should accept the token)
- =exp= - Expiration time
- =nbf= - Not before time
- =iat= - Issued at time
- =jti= - JWT ID (unique identifier)

*Common Use Cases:*
- Authentication after login
- API authorization
- Information exchange between services
- Single Sign-On (SSO)

** The Base64url Challenge
#+ATTR_BEAMER: :overlay <+->
Standard Base64 vs Base64url encoding:
- URL-safe variant replaces =+= with =-= and =/= with =_=
- Padding (=== ) often omitted
- Used to ensure tokens can be safely transmitted in URLs

*Every language handles this differently!*

* Language Implementations
** JavaScript (Browser) üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC javascript
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANT: In production, verify signature before parsing!
// This example is for demonstration only

// Decode the header part
const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(atob(headerPart));
console.log(decodedHeader);
#+END_SRC

*Note*: =atob()= handles base64 but not base64url specifically

** Node.js üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC javascript
// Using built-in modules
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANT: In production, verify signature before parsing!
// This example is for demonstration only

const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(
  Buffer.from(headerPart, 'base64').toString()
);
console.log(decodedHeader);
#+END_SRC

** TypeScript with Type Safety üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC typescript
interface JwtHeader {
  alg: string;
  typ: string;
  kid?: string;  // Key identifier, optional
}

function decodeJwtHeader(authHeader: string): JwtHeader {
  const token: string = authHeader.split(' ')[1];
  const headerPart: string = token.split('.')[0];
  
  // IMPORTANT: In production, verify signature before parsing!
  // This example is for demonstration only
  
  // Add padding if needed
  const base64 = headerPart.replace(/-/g, '+').replace(/_/g, '/');
  const padded = base64.padEnd(base64.length + (4 - (base64.length % 4)) % 4, '=');
  
  const decodedHeader: JwtHeader = JSON.parse(
    Buffer.from(padded, 'base64').toString()
  );
  return decodedHeader;
}
#+END_SRC

** Python Implementation üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC python
import base64
import json
import typing

def decode_jwt_header(auth_header: str) -> typing.Dict[str, str]:
    """Decode JWT header from Authorization header.
    
    IMPORTANT: In production, verify signature before parsing!
    This example is for demonstration only.
    """
    token = auth_header.split(' ')[1]
    header_part = token.split('.')[0]
    
    # Add padding if needed
    padding_needed = len(header_part) % 4
    if padding_needed:
        header_part += '=' * (4 - padding_needed)
    
    # Decode base64
    decoded_bytes = base64.b64decode(header_part.replace('-', '+').replace('_', '/'))
    decoded_str = decoded_bytes.decode('utf-8')
    
    # Parse JSON
    return json.loads(decoded_str)
#+END_SRC

** Functional Approaches: Clojure üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC clojure
;; IMPORTANT: In production, verify signature before parsing!
;; This example is for demonstration only.
(defn decode-jwt-header 
  "Decode JWT header from Authorization header."
  [auth-header]
  (let [token (second (clojure.string/split auth-header #" "))
        header-part (first (clojure.string/split token #"\."))
        decoder (Base64/getUrlDecoder)
        decoded-bytes (.decode decoder header-part)
        decoded-str (String. decoded-bytes)
        header (json/read-str decoded-str)]
    header))
#+END_SRC

*Note*: JVM's Base64 has a URL decoder built-in!

** Functional Approaches: Racket ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC racket
;; Convert base64url to standard base64 and decode
(define (base64url->bytes str)
  (define padding (make-string (modulo (- 0 (string-length str)) 4) #\=))
  (define base64 (string-map (Œª (c)
                               (match c
                                 [#\- #\+]
                                 [#\_ #\/]
                                 [_ c]))
                             str))
  (base64-decode (string-append base64 padding)))

;; IMPORTANT: In production, verify signature before parsing!
;; This example is for demonstration only and uses functional composition
(define (decode-jwt-header auth-header)
  ;; Pipeline of transformations
  (define token (second (string-split auth-header)))
  (define header-part (first (string-split token ".")))
  (define decoded-bytes (base64url->bytes header-part))
  (define decoded-str (bytes->string/utf-8 decoded-bytes))
  (string->jsexpr decoded-str))
#+END_SRC

** Low-Level Implementation: Rust ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC rust
#[derive(Debug, Serialize, Deserialize)]
struct JwtHeader {
    alg: String,
    typ: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    kid: Option<String>,  // Optional key identifier
}

/// Decode JWT header from Authorization header
/// 
/// # IMPORTANT
/// In production, verify signature before parsing!
/// This example is for demonstration only.
/// 
/// # Error Handling
/// Returns Result with either parsed header or descriptive error
fn decode_jwt_header(auth_header: &str) -> Result<JwtHeader, Box<dyn std::error::Error>> {
    // Extract token with error handling
    let token = auth_header.split_whitespace().nth(1).ok_or("Invalid auth header")?;
    let header_part = token.split('.').next().ok_or("Invalid token format")?;
    
    // Decode base64url to bytes (using proper URL-safe decoder)
    let decoded_bytes = general_purpose::URL_SAFE_NO_PAD.decode(header_part)?;
    
    // Parse JSON with strong typing
    let header: JwtHeader = serde_json::from_slice(&decoded_bytes)?;
    Ok(header)
}
#+END_SRC

* Analysis
** Common Patterns & Variations üß©
#+ATTR_BEAMER: :overlay <+->
1. *Token extraction*: Split by space or regex
2. *Base64url handling*:
   - Character replacement (=-= ‚Üí =+=, =_= ‚Üí =/=)
   - Padding calculation
   - URL-safe decoder availability (JVM advantage)
3. *JSON parsing*: Native vs libraries
4. *Error handling*: Idiomatic differences

** Cross-Language Performance Analysis ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
| Language   | Parsing Time (Œºs) | Memory Usage (KB) |
|------------+-------------------+-------------------|
| Rust       |               5.2 |               1.8 |
| JavaScript |              24.7 |              12.3 |
| Python     |              30.1 |              15.7 |
| Clojure    |              45.8 |              28.4 |
| Shell      |             180.3 |               8.9 |

*Note: Average of 1000 runs, single-threaded*

* Security Considerations
** JWT Security Best Practices ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *Always verify signatures before parsing or using payload*
- Use strong algorithms (prefer RS256/ES256 over HS256)
- Implement proper key management (rotation, secure storage)
- Set appropriate token lifetimes (short-lived access tokens)
- Include essential claims (iss, sub, exp, aud, iat)

** Common JWT Attacks ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *"alg": "none" attack* - Attacker removes signature validation requirement
- *Algorithm confusion* - Switching from asymmetric (RS256) to symmetric (HS256)
- *Token tampering* - Modifying claims without invalidating signature
- *Token injection* - Using a token from one context in another
- *Replay attacks* - Reusing captured tokens

** Token Lifecycle Management ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *Refresh token patterns* - Securely obtain new access tokens
- *Token revocation* - Invalidate tokens before expiration
- *Token validation pipeline* - Proper order of operations
- *Blacklisting* - Tracking compromised or logged-out tokens

#+BEGIN_SRC dot :file images/token-lifecycle.png :cmdline -Kdot -Tpng
digraph {
  node [shape=box, style=filled, fillcolor="#f5f5f5"];
  edge [fontname="Arial"];
  
  issue [label="Token Issuance", fillcolor="#e6ffe6"];
  validate [label="Token Validation", fillcolor="#e6f3ff"];
  refresh [label="Token Refresh", fillcolor="#fff0e6"];
  revoke [label="Token Revocation", fillcolor="#ffe6e6"];
  
  issue -> validate -> refresh -> validate;
  validate -> revoke;
}
#+END_SRC

* Real-World Applications
** Cross-Language Implementation Comparison
#+ATTR_BEAMER: :overlay <+->
| Feature | JavaScript | Python | Rust | Clojure | TypeScript |
|---------|------------|--------|------|---------|------------|
| Type Safety | Limited | Optional | Strong | Dynamic | Strong |
| Base64 Handling | Manual | Built-in | Crates | JVM | Manual |
| Error Handling | try/catch | Exceptions | Result | Monadic | try/catch |
| Performance | Medium | Low | High | Medium | Medium |
| JWT Libraries | Many | Several | Few | Few | Many |

** JWT in Production
#+ATTR_BEAMER: :overlay <+->
- API Gateway token validation
- Microservice authorization
- Single Sign-On implementations
- Mobile app authentication
- Server-to-server communication

** JWT Flow
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC dot :file images/jwt-flow-detailed.png :cmdline -Kdot -Tpng
digraph {
  rankdir=LR;
  node [shape=box, style=rounded];
  subgraph cluster_validation {
    label="Secure Validation Process";
    style=dashed;
    color=gray;
    "Extract JWT" -> "Verify Signature" -> "Validate Claims" -> "Check Revocation";
  }
  
  Client -> "Auth Service" [label="1. Login"];
  "Auth Service" -> Client [label="2. JWT"];
  Client -> "API Gateway" [label="3. Request + JWT"];
  "API Gateway" -> "Extract JWT";
  "Check Revocation" -> "Microservice" [label="4. Authorized Request"];
  "Microservice" -> Client [label="5. Response"];
}
#+END_SRC

* Debugging & Troubleshooting
** Common JWT Issues and Solutions
#+ATTR_BEAMER: :overlay <+->
- *Invalid signature* - Check key matching, algorithm consistency
- *Expired tokens* - Verify client/server clock synchronization
- *Malformed tokens* - Inspect encoding, ensure proper base64url handling
- *Missing claims* - Validate token structure against expected schema
- *Algorithm mismatch* - Confirm header alg matches implementation

** Debugging Tools
#+ATTR_BEAMER: :overlay <+->
- Online JWT debugger (jwt.io)
- Language-specific JWT libraries with debug options
- Base64 inspection tools
- Request/response inspection with developer tools

* Conclusion
** Cross-Paradigm Insights
#+ATTR_BEAMER: :overlay <+->
| Paradigm | Strengths | JWT Application |
|----------|-----------|----------------|
| Object-Oriented | Encapsulation, inheritance | Token with validation methods |
| Functional | Composition, immutability | Transform pipeline for parsing |
| Procedural | Simplicity, performance | Lightweight validators |
| Reactive | Event handling | Token verification in async flows |

** Takeaways
#+ATTR_BEAMER: :overlay <+->
1. Base64url encoding requires special attention
2. Each language has idiomatic parsing advantages
3. Functional approaches shine for transformation pipelines
4. Security first: always verify signatures before parsing
5. Consider token lifecycle for complete implementation
6. Libraries save time but understanding internals matters
7. Follow language-specific best practices

** Learning Resources
#+ATTR_BEAMER: :overlay <+->
- JWT RFC 7519: https://tools.ietf.org/html/rfc7519
- JWT Security Best Practices (IETF): https://datatracker.ietf.org/doc/html/draft-ietf-oauth-jwt-bcp
- OWASP JWT Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html
- Language-specific security guides: see repository docs

** JWT Glossary for Beginners üî∞
#+ATTR_BEAMER: :overlay <+->
| Term | Definition |
|------|------------|
| JWT | JSON Web Token: a compact, URL-safe means of representing claims to be transferred between parties |
| Claims | Pieces of information asserted about a subject (e.g., user ID, expiration time) |
| Base64url | A URL-safe variant of Base64 encoding that can be included in URLs without escaping |
| Header | First part of JWT containing metadata like algorithm used for signing |
| Payload | Second part of JWT containing the actual claims data |
| Signature | Third part of JWT that verifies the token hasn't been altered |
| HMAC | Hash-based Message Authentication Code: technique for ensuring data integrity using a secret key |
| RSA | Public-key cryptosystem commonly used for JWT signatures |
| Stateless | Authentication not requiring server-side session storage |
| Bearer token | Type of access token where possession of the token is sufficient for authentication |

** Python Security Best Practices ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC python
import jwt
from cryptography.hazmat.primitives.constant_time import bytes_eq
from typing import Dict, Any, Optional, List, Union

# Define explicit typing for JWT claims
class JWTClaims(TypedDict):
    iss: str  # issuer
    sub: str  # subject
    exp: int  # expiration time
    iat: int  # issued at time
    aud: Optional[Union[str, List[str]]]  # audience

def verify_and_decode_token(token: str, key: str, algorithms: List[str] = ['RS256']) -> JWTClaims:
    """Securely verify and decode a JWT token with proper error handling.
    
    IMPORTANT: This function validates the signature BEFORE processing payload.
    """
    try:
        # Explicitly specify allowed algorithms (prevent 'none' algorithm attack)
        # Validate signature first, then decode payload
        payload = jwt.decode(
            token,
            key,
            algorithms=algorithms,  # Explicitly specify allowed algorithms
            options={"verify_signature": True}
        )
        return payload
    except jwt.ExpiredSignatureError:
        # Specific exception for expired token
        raise ValueError("Token has expired")
    except jwt.InvalidSignatureError:
        # Use generic error that doesn't reveal signature details
        raise ValueError("Authentication failed")
    except jwt.DecodeError:
        # Generic decode error
        raise ValueError("Invalid token")
    except jwt.InvalidAlgorithmError:
        raise ValueError("Invalid token algorithm")
    except Exception:
        # Catch-all with generic message to avoid information leakage
        raise ValueError("Authentication failed")
#+END_SRC

** Functional Pipelines: Enhanced Clojure Example üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC clojure
;; Leveraging Clojure's functional approach with thread-first macro
;; for cleaner transformation pipeline

(defn decode-base64url
  "Decode base64url-encoded string to string"
  [base64url-str]
  (-> base64url-str
      (java.util.Base64/getUrlDecoder)
      (.decode)
      (String.)))

(defn extract-token
  "Extract token from auth header"
  [auth-header]
  (-> auth-header
      (clojure.string/split #" ")
      (second)))

(defn extract-header-part
  "Extract header part from token"
  [token]
  (-> token
      (clojure.string/split #"\.")
      (first)))

(defn parse-json
  "Parse JSON string to Clojure map"
  [json-str]
  (json/read-str json-str :key-fn keyword))

;; IMPORTANT: In production, verify signature before parsing!
;; This example demonstrates functional composition for readability
(defn decode-jwt-header
  "Extract and decode JWT header using a functional pipeline"
  [auth-header]
  (-> auth-header
      (extract-token)
      (extract-header-part)
      (decode-base64url)
      (parse-json)))
#+END_SRC

** Questions?
#+ATTR_BEAMER: :overlay <+->
Thank you!

*Slides & examples available at:* 
github.com/aidan-pace/jwt-parsing-examples

*Difficulty levels:* üî∞ Beginner | üß© Intermediate | ‚ö†Ô∏è Advanced