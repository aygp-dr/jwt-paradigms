#+TITLE: An√°lisis de Cabeceras JWT a trav√©s de Paradigmas de Programaci√≥n
#+AUTHOR: Aidan Pace
#+EMAIL: apace@defrecord.com
#+DATE: [2025-04-28]
#+LANGUAGE: es
#+OPTIONS: toc:nil num:nil ^:nil
#+STARTUP: beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation,aspectratio=169]
#+BEAMER_THEME: metropolis
#+BEAMER_COLOR_THEME: default
#+BEAMER_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{Agenda}\tableofcontents[currentsection]\end{frame}}

* Introducci√≥n
** An√°lisis de Cabeceras JWT a trav√©s de Paradigmas de Programaci√≥n
#+ATTR_BEAMER: :overlay <+->
- Una exploraci√≥n entre lenguajes de t√©cnicas de an√°lisis de cabeceras JWT
- PyCon US 2025, 14 de mayo - 22 de mayo, 2025
- Aidan Pace (@aygp-dr)

** Lo que cubriremos
#+ATTR_BEAMER: :overlay <+->
- Contexto hist√≥rico y evoluci√≥n de la autenticaci√≥n
- Estructura JWT y fundamentos (üî∞ amigable para principiantes)
- Desaf√≠os de la codificaci√≥n Base64url
- Patrones de an√°lisis de cabeceras en diferentes lenguajes
- Enfoques funcionales vs orientados a objetos
- Modismos y mejores pr√°cticas espec√≠ficos de cada lenguaje
- Consideraciones de seguridad y ataques comunes
- An√°lisis de rendimiento y aplicaciones del mundo real

* Evoluci√≥n de la Autenticaci√≥n
** Contexto Hist√≥rico de la Autenticaci√≥n
#+ATTR_BEAMER: :overlay <+->
- Autenticaci√≥n temprana: Pares de nombre de usuario/contrase√±a
- Sesiones del lado del servidor con cookies (con estado)
- Surgimiento de la autenticaci√≥n basada en tokens (sin estado)
- Estandarizaci√≥n JWT (RFC 7519, mayo 2015)
- Flujos de autenticaci√≥n modernos (OAuth 2.0, OIDC)

* Conceptos B√°sicos de JWT
** Repaso de la Estructura JWT üî∞
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC text
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
#+END_SRC

Tres segmentos codificados en base64url separados por puntos:
1. *Cabecera* (algoritmo y tipo de token)
2. *Carga √∫til* (reclamaciones/claims)
3. *Firma*

#+BEGIN_SRC dot :file images/jwt-structure.png :cmdline -Kdot -Tpng
digraph {
  rankdir=LR;
  node [shape=box, style=filled, fillcolor="#e6f3ff", fontname="monospace"];
  edge [fontname="Arial"];
  
  Header [label="Cabecera\n{\"alg\":\"HS256\",\n\"typ\":\"JWT\"}"];
  Payload [label="Carga √∫til\n{\"sub\":\"1234\",\n\"name\":\"User\",\n\"exp\":1516239022}"];
  Signature [label="Firma\nHMAC-SHA256(\n  base64UrlEncode(header) + '.' +\n  base64UrlEncode(payload),\n  secret\n)"];
  
  Header -> Payload [label="  .  "];
  Payload -> Signature [label="  .  "];
}
#+END_SRC

** Reclamaciones JWT y Casos de Uso üî∞
#+ATTR_BEAMER: :overlay <+->
*Reclamaciones Est√°ndar:*
- =iss= - Emisor (qui√©n cre√≥ el token)
- =sub= - Sujeto (a qui√©n se refiere el token)
- =aud= - Audiencia (qui√©n debe aceptar el token)
- =exp= - Tiempo de expiraci√≥n
- =nbf= - No antes de (este tiempo)
- =iat= - Emitido en (este tiempo)
- =jti= - ID JWT (identificador √∫nico)

*Casos de Uso Comunes:*
- Autenticaci√≥n despu√©s del inicio de sesi√≥n
- Autorizaci√≥n de API
- Intercambio de informaci√≥n entre servicios
- Inicio de Sesi√≥n √önico (SSO)

** El Desaf√≠o Base64url
#+ATTR_BEAMER: :overlay <+->
Base64 est√°ndar vs codificaci√≥n Base64url:
- La variante segura para URL reemplaza =+= con =-= y =/= con =_=
- El relleno (=== ) a menudo se omite
- Se utiliza para garantizar que los tokens puedan transmitirse de forma segura en las URL

*¬°Cada lenguaje maneja esto de manera diferente!*

* Implementaciones en Lenguajes
** JavaScript (Navegador) üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC javascript
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
// Este ejemplo es solo para demostraci√≥n

// Decodificar la parte de la cabecera
const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(atob(headerPart));
console.log(decodedHeader);
#+END_SRC

*Nota*: =atob()= maneja base64 pero no espec√≠ficamente base64url

** Node.js üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC javascript
// Usando m√≥dulos incorporados
const authHeader = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOi..."
const token = authHeader.split(' ')[1];

// IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
// Este ejemplo es solo para demostraci√≥n

const headerPart = token.split('.')[0];
const decodedHeader = JSON.parse(
  Buffer.from(headerPart, 'base64').toString()
);
console.log(decodedHeader);
#+END_SRC

** TypeScript con Seguridad de Tipos üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC typescript
interface JwtHeader {
  alg: string;
  typ: string;
  kid?: string;  // Identificador de clave, opcional
}

function decodeJwtHeader(authHeader: string): JwtHeader {
  const token: string = authHeader.split(' ')[1];
  const headerPart: string = token.split('.')[0];
  
  // IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
  // Este ejemplo es solo para demostraci√≥n
  
  // Agregar relleno si es necesario
  const base64 = headerPart.replace(/-/g, '+').replace(/_/g, '/');
  const padded = base64.padEnd(base64.length + (4 - (base64.length % 4)) % 4, '=');
  
  const decodedHeader: JwtHeader = JSON.parse(
    Buffer.from(padded, 'base64').toString()
  );
  return decodedHeader;
}
#+END_SRC

** Implementaci√≥n Python üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC python
import base64
import json
import typing

def decode_jwt_header(auth_header: str) -> typing.Dict[str, str]:
    """Decodifica la cabecera JWT del encabezado de autorizaci√≥n.
    
    IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
    Este ejemplo es solo para demostraci√≥n.
    """
    token = auth_header.split(' ')[1]
    header_part = token.split('.')[0]
    
    # Agregar relleno si es necesario
    padding_needed = len(header_part) % 4
    if padding_needed:
        header_part += '=' * (4 - padding_needed)
    
    # Decodificar base64
    decoded_bytes = base64.b64decode(header_part.replace('-', '+').replace('_', '/'))
    decoded_str = decoded_bytes.decode('utf-8')
    
    # Analizar JSON
    return json.loads(decoded_str)
#+END_SRC

** Enfoques Funcionales: Clojure üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC clojure
;; IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
;; Este ejemplo es solo para demostraci√≥n.
(defn decode-jwt-header 
  "Decodifica la cabecera JWT del encabezado de autorizaci√≥n."
  [auth-header]
  (let [token (second (clojure.string/split auth-header #" "))
        header-part (first (clojure.string/split token #"\."))
        decoder (Base64/getUrlDecoder)
        decoded-bytes (.decode decoder header-part)
        decoded-str (String. decoded-bytes)
        header (json/read-str decoded-str)]
    header))
#+END_SRC

*Nota*: ¬°Base64 de la JVM tiene un decodificador URL incorporado!

** Enfoques Funcionales: Racket ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC racket
;; Convertir base64url a base64 est√°ndar y decodificar
(define (base64url->bytes str)
  (define padding (make-string (modulo (- 0 (string-length str)) 4) #\=))
  (define base64 (string-map (Œª (c)
                               (match c
                                 [#\- #\+]
                                 [#\_ #\/]
                                 [_ c]))
                             str))
  (base64-decode (string-append base64 padding)))

;; IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
;; Este ejemplo es solo para demostraci√≥n y usa composici√≥n funcional
(define (decode-jwt-header auth-header)
  ;; Tuber√≠a de transformaciones
  (define token (second (string-split auth-header)))
  (define header-part (first (string-split token ".")))
  (define decoded-bytes (base64url->bytes header-part))
  (define decoded-str (bytes->string/utf-8 decoded-bytes))
  (string->jsexpr decoded-str))
#+END_SRC

** Implementaci√≥n de Bajo Nivel: Rust ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC rust
#[derive(Debug, Serialize, Deserialize)]
struct JwtHeader {
    alg: String,
    typ: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    kid: Option<String>,  // Identificador de clave opcional
}

/// Decodifica la cabecera JWT del encabezado de autorizaci√≥n
/// 
/// # IMPORTANTE
/// ¬°En producci√≥n, verifica la firma antes de analizar!
/// Este ejemplo es solo para demostraci√≥n.
/// 
/// # Manejo de Errores
/// Devuelve Result con la cabecera analizada o un error descriptivo
fn decode_jwt_header(auth_header: &str) -> Result<JwtHeader, Box<dyn std::error::Error>> {
    // Extraer token con manejo de errores
    let token = auth_header.split_whitespace().nth(1).ok_or("Encabezado de autenticaci√≥n inv√°lido")?;
    let header_part = token.split('.').next().ok_or("Formato de token inv√°lido")?;
    
    // Decodificar base64url a bytes (usando un decodificador seguro para URL adecuado)
    let decoded_bytes = general_purpose::URL_SAFE_NO_PAD.decode(header_part)?;
    
    // Analizar JSON con tipado fuerte
    let header: JwtHeader = serde_json::from_slice(&decoded_bytes)?;
    Ok(header)
}
#+END_SRC

* An√°lisis
** Patrones Comunes y Variaciones üß©
#+ATTR_BEAMER: :overlay <+->
1. *Extracci√≥n de tokens*: Dividir por espacio o regex
2. *Manejo de Base64url*:
   - Reemplazo de caracteres (=-= ‚Üí =+=, =_= ‚Üí =/=)
   - C√°lculo de relleno
   - Disponibilidad de decodificador seguro para URL (ventaja JVM)
3. *An√°lisis JSON*: Nativo vs bibliotecas
4. *Manejo de errores*: Diferencias idiom√°ticas

** An√°lisis de Rendimiento entre Lenguajes ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
| Lenguaje   | Tiempo de an√°lisis (Œºs) | Uso de memoria (KB) |
|------------+-------------------------+---------------------|
| Rust       |                     5.2 |                 1.8 |
| JavaScript |                    24.7 |                12.3 |
| Python     |                    30.1 |                15.7 |
| Clojure    |                    45.8 |                28.4 |
| Shell      |                   180.3 |                 8.9 |

*Nota: Promedio de 1000 ejecuciones, un solo hilo*

* Consideraciones de Seguridad
** Mejores Pr√°cticas de Seguridad JWT ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *Siempre verificar firmas antes de analizar o usar la carga √∫til*
- Usar algoritmos fuertes (preferir RS256/ES256 sobre HS256)
- Implementar gesti√≥n de claves adecuada (rotaci√≥n, almacenamiento seguro)
- Establecer tiempos de vida de token apropiados (tokens de acceso de corta duraci√≥n)
- Incluir reclamaciones esenciales (iss, sub, exp, aud, iat)

** Ataques JWT Comunes ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *Ataque "alg": "none"* - El atacante elimina el requisito de validaci√≥n de firma
- *Confusi√≥n de algoritmo* - Cambiar de asim√©trico (RS256) a sim√©trico (HS256)
- *Manipulaci√≥n de tokens* - Modificar reclamaciones sin invalidar la firma
- *Inyecci√≥n de tokens* - Usar un token de un contexto en otro
- *Ataques de repetici√≥n* - Reutilizar tokens capturados

** Gesti√≥n del Ciclo de Vida de Tokens ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
- *Patrones de token de actualizaci√≥n* - Obtener nuevos tokens de acceso de forma segura
- *Revocaci√≥n de tokens* - Invalidar tokens antes de la expiraci√≥n
- *Tuber√≠a de validaci√≥n de tokens* - Orden adecuado de operaciones
- *Lista negra* - Seguimiento de tokens comprometidos o cerrados de sesi√≥n

#+BEGIN_SRC dot :file images/token-lifecycle.png :cmdline -Kdot -Tpng
digraph {
  node [shape=box, style=filled, fillcolor="#f5f5f5"];
  edge [fontname="Arial"];
  
  issue [label="Emisi√≥n de Token", fillcolor="#e6ffe6"];
  validate [label="Validaci√≥n de Token", fillcolor="#e6f3ff"];
  refresh [label="Actualizaci√≥n de Token", fillcolor="#fff0e6"];
  revoke [label="Revocaci√≥n de Token", fillcolor="#ffe6e6"];
  
  issue -> validate -> refresh -> validate;
  validate -> revoke;
}
#+END_SRC

* Aplicaciones del Mundo Real
** Comparaci√≥n de Implementaci√≥n entre Lenguajes
#+ATTR_BEAMER: :overlay <+->
| Caracter√≠stica | JavaScript | Python | Rust | Clojure | TypeScript |
|----------------|------------|--------|------|---------|------------|
| Seguridad de tipos | Limitada | Opcional | Fuerte | Din√°mica | Fuerte |
| Manejo de Base64 | Manual | Incorporado | Crates | JVM | Manual |
| Manejo de errores | try/catch | Excepciones | Result | Mon√°dico | try/catch |
| Rendimiento | Medio | Bajo | Alto | Medio | Medio |
| Bibliotecas JWT | Muchas | Varias | Pocas | Pocas | Muchas |

** JWT en Producci√≥n
#+ATTR_BEAMER: :overlay <+->
- Validaci√≥n de tokens en API Gateway
- Autorizaci√≥n de microservicios
- Implementaciones de Inicio de Sesi√≥n √önico
- Autenticaci√≥n de aplicaciones m√≥viles
- Comunicaci√≥n servidor a servidor

** Flujo JWT
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC dot :file images/jwt-flow-detailed.png :cmdline -Kdot -Tpng
digraph {
  rankdir=LR;
  node [shape=box, style=rounded];
  subgraph cluster_validation {
    label="Proceso de Validaci√≥n Segura";
    style=dashed;
    color=gray;
    "Extraer JWT" -> "Verificar Firma" -> "Validar Reclamaciones" -> "Verificar Revocaci√≥n";
  }
  
  Client -> "Servicio Auth" [label="1. Inicio de sesi√≥n"];
  "Servicio Auth" -> Client [label="2. JWT"];
  Client -> "API Gateway" [label="3. Solicitud + JWT"];
  "API Gateway" -> "Extraer JWT";
  "Verificar Revocaci√≥n" -> "Microservicio" [label="4. Solicitud Autorizada"];
  "Microservicio" -> Client [label="5. Respuesta"];
}
#+END_SRC

* Depuraci√≥n y Soluci√≥n de Problemas
** Problemas Comunes de JWT y Soluciones
#+ATTR_BEAMER: :overlay <+->
- *Firma inv√°lida* - Verificar coincidencia de claves, consistencia de algoritmo
- *Tokens expirados* - Verificar sincronizaci√≥n de reloj cliente/servidor
- *Tokens mal formados* - Inspeccionar codificaci√≥n, asegurar manejo adecuado de base64url
- *Reclamaciones faltantes* - Validar estructura del token contra esquema esperado
- *Desajuste de algoritmo* - Confirmar que el alg de cabecera coincide con la implementaci√≥n

** Herramientas de Depuraci√≥n
#+ATTR_BEAMER: :overlay <+->
- Depurador JWT en l√≠nea (jwt.io)
- Bibliotecas JWT espec√≠ficas de lenguaje con opciones de depuraci√≥n
- Herramientas de inspecci√≥n Base64
- Inspecci√≥n de solicitudes/respuestas con herramientas de desarrollador

* Conclusi√≥n
** Perspectivas entre Paradigmas
#+ATTR_BEAMER: :overlay <+->
| Paradigma | Fortalezas | Aplicaci√≥n JWT |
|-----------|------------|----------------|
| Orientado a objetos | Encapsulaci√≥n, herencia | Token con m√©todos de validaci√≥n |
| Funcional | Composici√≥n, inmutabilidad | Tuber√≠a de transformaci√≥n para an√°lisis |
| Procedural | Simplicidad, rendimiento | Validadores ligeros |
| Reactivo | Manejo de eventos | Verificaci√≥n de token en flujos as√≠ncronos |

** Conclusiones Principales
#+ATTR_BEAMER: :overlay <+->
1. La codificaci√≥n Base64url requiere atenci√≥n especial
2. Cada lenguaje tiene ventajas idiom√°ticas de an√°lisis
3. Los enfoques funcionales brillan para tuber√≠as de transformaci√≥n
4. Seguridad primero: siempre verificar firmas antes de analizar
5. Considerar el ciclo de vida del token para una implementaci√≥n completa
6. Las bibliotecas ahorran tiempo pero entender los mecanismos internos es importante
7. Seguir las mejores pr√°cticas espec√≠ficas del lenguaje

** Recursos de Aprendizaje
#+ATTR_BEAMER: :overlay <+->
- JWT RFC 7519: https://tools.ietf.org/html/rfc7519
- Mejores Pr√°cticas de Seguridad JWT (IETF): https://datatracker.ietf.org/doc/html/draft-ietf-oauth-jwt-bcp
- Hoja de trucos OWASP JWT: https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html
- Gu√≠as de seguridad espec√≠ficas de lenguaje: ver documentaci√≥n del repositorio

** Glosario JWT para Principiantes üî∞
#+ATTR_BEAMER: :overlay <+->
| T√©rmino | Definici√≥n |
|---------|------------|
| JWT | JSON Web Token: un medio compacto y seguro para URL de representar reclamaciones para transferir entre partes |
| Reclamaciones | Piezas de informaci√≥n afirmadas sobre un sujeto (p. ej., ID de usuario, tiempo de expiraci√≥n) |
| Base64url | Una variante de la codificaci√≥n Base64 segura para URL que puede incluirse en URLs sin escape |
| Cabecera | Primera parte del JWT que contiene metadatos como el algoritmo utilizado para firmar |
| Carga √∫til | Segunda parte del JWT que contiene los datos de reclamaciones reales |
| Firma | Tercera parte del JWT que verifica que el token no ha sido alterado |
| HMAC | C√≥digo de Autenticaci√≥n de Mensajes basado en Hash: t√©cnica para garantizar la integridad de datos usando una clave secreta |
| RSA | Criptosistema de clave p√∫blica com√∫nmente usado para firmas JWT |
| Sin estado | Autenticaci√≥n que no requiere almacenamiento de sesi√≥n del lado del servidor |
| Token al portador | Tipo de token de acceso donde la posesi√≥n del token es suficiente para la autenticaci√≥n |

** Mejores Pr√°cticas de Seguridad Python ‚ö†Ô∏è
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC python
import jwt
from cryptography.hazmat.primitives.constant_time import bytes_eq
from typing import Dict, Any, Optional, List, Union

# Definir tipado expl√≠cito para reclamaciones JWT
class JWTClaims(TypedDict):
    iss: str  # emisor
    sub: str  # sujeto
    exp: int  # tiempo de expiraci√≥n
    iat: int  # emitido en
    aud: Optional[Union[str, List[str]]]  # audiencia

def verify_and_decode_token(token: str, key: str, algorithms: List[str] = ['RS256']) -> JWTClaims:
    """Verificar y decodificar un token JWT de forma segura con manejo de errores adecuado.
    
    IMPORTANTE: Esta funci√≥n valida la firma ANTES de procesar la carga √∫til.
    """
    try:
        # Especificar expl√≠citamente los algoritmos permitidos (prevenir ataque de algoritmo 'none')
        # Validar firma primero, luego decodificar carga √∫til
        payload = jwt.decode(
            token,
            key,
            algorithms=algorithms,  # Especificar expl√≠citamente algoritmos permitidos
            options={"verify_signature": True}
        )
        return payload
    except jwt.ExpiredSignatureError:
        # Excepci√≥n espec√≠fica para token expirado
        raise ValueError("El token ha expirado")
    except jwt.InvalidSignatureError:
        # Usar error gen√©rico que no revela detalles de firma
        raise ValueError("Autenticaci√≥n fallida")
    except jwt.DecodeError:
        # Error de decodificaci√≥n gen√©rico
        raise ValueError("Token inv√°lido")
    except jwt.InvalidAlgorithmError:
        raise ValueError("Algoritmo de token inv√°lido")
    except Exception:
        # Captura todo con mensaje gen√©rico para evitar fugas de informaci√≥n
        raise ValueError("Autenticaci√≥n fallida")
#+END_SRC

** Tuber√≠as Funcionales: Ejemplo Clojure Mejorado üß©
#+ATTR_BEAMER: :overlay <+->
#+BEGIN_SRC clojure
;; Aprovechando el enfoque funcional de Clojure con macro thread-first
;; para una tuber√≠a de transformaci√≥n m√°s limpia

(defn decode-base64url
  "Decodificar cadena codificada en base64url a cadena"
  [base64url-str]
  (-> base64url-str
      (java.util.Base64/getUrlDecoder)
      (.decode)
      (String.)))

(defn extract-token
  "Extraer token del encabezado de autorizaci√≥n"
  [auth-header]
  (-> auth-header
      (clojure.string/split #" ")
      (second)))

(defn extract-header-part
  "Extraer parte de cabecera del token"
  [token]
  (-> token
      (clojure.string/split #"\.")
      (first)))

(defn parse-json
  "Analizar cadena JSON a mapa Clojure"
  [json-str]
  (json/read-str json-str :key-fn keyword))

;; IMPORTANTE: ¬°En producci√≥n, verifica la firma antes de analizar!
;; Este ejemplo demuestra la composici√≥n funcional para legibilidad
(defn decode-jwt-header
  "Extraer y decodificar cabecera JWT usando una tuber√≠a funcional"
  [auth-header]
  (-> auth-header
      (extract-token)
      (extract-header-part)
      (decode-base64url)
      (parse-json)))
#+END_SRC

** ¬øPreguntas?
#+ATTR_BEAMER: :overlay <+->
¬°Gracias!

*Diapositivas y ejemplos disponibles en:* 
github.com/aidan-pace/jwt-parsing-examples

*Niveles de dificultad:* üî∞ Principiante | üß© Intermedio | ‚ö†Ô∏è Avanzado